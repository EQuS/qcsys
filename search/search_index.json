{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Welcome to qcsys","text":"<p><code>qcsys</code> leverages JAX to enable an auto differentiable and accelerated numerical Hamiltonian diagonalization framework for coupled quantum systems.</p> <p>More docs are comming soon!</p>"},{"location":"getting_started/docs.html","title":"Docs","text":""},{"location":"getting_started/docs.html#documentation","title":"Documentation","text":"<p>Documentation should be viewable here: https://github.com/pages/EQuS/qcsys/ </p>"},{"location":"getting_started/docs.html#build-and-view-locally","title":"Build and view locally","text":"<p>To view documentation locally, plesae make sure the install the requirements under the <code>docs</code> extra, as specified above. Then, run the following:</p> <pre><code>mkdocs serve\n</code></pre> <p>The documentation should now be at the url provided by the above command. </p>"},{"location":"getting_started/docs.html#updating-docs","title":"Updating Docs","text":"<p>The documentation should be updated automatically when any changes are made to the <code>main</code> branch. However, updates can also be forced by running:</p> <pre><code>mkdocs gh-deploy --force\n</code></pre> <p>This will build your documentation and deploy it to a branch gh-pages in your repository.</p>"},{"location":"getting_started/installation.html","title":"Installation","text":""},{"location":"getting_started/installation.html#installation","title":"Installation","text":"<p>Conda users, please make sure to <code>conda install pip</code> before running any pip installation if you want to install <code>qcsys</code> into your conda environment.</p> <p><code>qcsys</code> may soon be published on PyPI. Once it is, simply run the following code to install the package:</p> <pre><code>pip install qcsys\n</code></pre> <p>If you also want to download the dependencies needed to run optional tutorials, please use <code>pip install qcsys[dev,docs]</code> or <code>pip install 'qcsys[dev,docs]'</code> (for <code>zsh</code> users).</p> <p>To check if the installation was successful, run:</p> <pre><code>&gt;&gt;&gt; import qcsys\n</code></pre>"},{"location":"getting_started/installation.html#building-from-source","title":"Building from source","text":"<p>To build <code>qcsys</code> from source, pip install using:</p> <pre><code>git clone https://github.com/EQuS/qcsys.git\ncd qcsys\npip install --upgrade .\n</code></pre> <p>If you also want to download the dependencies needed to run optional tutorials, please use <code>pip install --upgrade .[dev,docs]</code> or <code>pip install --upgrade '.[dev,docs]'</code> (for <code>zsh</code> users).</p>"},{"location":"getting_started/installation.html#installation-for-devs","title":"Installation for Devs","text":"<p>If you intend to contribute to this project, please install <code>qcsys</code> in editable mode as follows:</p> <pre><code>git clone https://github.com/EQuS/qcsys.git\ncd qcsys\npip install -e .[dev,docs]\n</code></pre> <p>Please use <code>pip install -e '.[dev,docs]'</code> if you are a <code>zsh</code> user.</p>"},{"location":"reference/summary.html","title":"Summary","text":"<ul> <li>qcsys<ul> <li>analysis<ul> <li>sweeps</li> </ul> </li> <li>common<ul> <li>utils</li> </ul> </li> <li>devices<ul> <li>ats</li> <li>base</li> <li>drive</li> <li>fluxonium</li> <li>ideal_qubit</li> <li>kno</li> <li>resonator</li> <li>system</li> <li>transmon</li> <li>truncated_transmon</li> <li>tunable_transmon</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/qcsys/index.html","title":"qcsys","text":"<p>qcsys</p>"},{"location":"reference/qcsys/index.html#qcsys.ATS","title":"<code>ATS</code>","text":"<p>               Bases: <code>FluxDevice</code></p> <p>ATS Device.</p> Source code in <code>qcsys/devices/ats.py</code> <pre><code>@struct.dataclass\nclass ATS(FluxDevice):        \n    \"\"\"\n    ATS Device.\n    \"\"\"\n\n    def common_ops(self):\n        \"\"\" Written in the linear basis. \"\"\"\n        ops = {}\n\n        N = self.N_pre_diag\n        ops[\"id\"] = jqt.identity(N)\n        ops[\"a\"] = jqt.destroy(N)\n        ops[\"a_dag\"] = jqt.create(N)\n        ops[\"phi\"] = self.phi_zpf()*(ops[\"a\"] + ops[\"a_dag\"])  \n        ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n        return ops\n\n    def phi_zpf(self):\n        \"\"\"Return Phase ZPF.\"\"\"\n        return (2*self.params[\"Ec\"]/self.params[\"El\"])**(.25)\n\n    def n_zpf(self):\n        \"\"\"Return Charge ZPF.\"\"\"\n        return (self.params[\"El\"]/(32*self.params[\"Ec\"]))**(.25)\n\n    def get_linear_\u03c9(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return jnp.sqrt(8*self.params[\"El\"]*self.params[\"Ec\"])\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_\u03c9()\n        return w*(self.linear_ops[\"a_dag\"]@self.linear_ops[\"a\"] + 0.5 * self.linear_ops[\"id\"])\n\n    @staticmethod\n    def get_H_nonlinear_static(phi_op, Ej, dEj, Ej2, phi_sum, phi_delta):\n        cos_phi_op = jqt.cosm(phi_op)\n        sin_phi_op = jqt.sinm(phi_op)\n\n        cos_2phi_op = cos_phi_op @ cos_phi_op - sin_phi_op @ sin_phi_op\n        sin_2phi_op = 2 * cos_phi_op @ sin_phi_op\n\n        H_nl_Ej = - 2 * Ej * (\n            cos_phi_op * jnp.cos(2 * jnp.pi * phi_delta) \n            - sin_phi_op * jnp.sin(2 * jnp.pi * phi_delta)\n        ) * jnp.cos(2 * jnp.pi * phi_sum)\n        H_nl_dEj = 2 * dEj * (\n            sin_phi_op * jnp.cos(2 * jnp.pi * phi_delta)\n            + cos_phi_op * jnp.sin(2 * jnp.pi * phi_delta)\n        ) * jnp.sin(2 * jnp.pi * phi_sum) \n        H_nl_Ej2 = 2 * Ej2 * (\n            cos_2phi_op * jnp.cos(2 * 2 * jnp.pi * phi_delta)\n            - sin_2phi_op * jnp.sin(2 * 2 * jnp.pi * phi_delta)\n        ) * jnp.cos(2 * 2 * jnp.pi * phi_sum)\n\n        H_nl = H_nl_Ej + H_nl_dEj + H_nl_Ej2\n\n\n        # id_op = jqt.identity_like(phi_op)\n        # phi_delta_ext_op = self.params[\"phi_delta_ext\"] * id_op\n        # H_nl_old = - 2 * Ej * jqt.cosm(phi_op + 2 * jnp.pi * phi_delta_ext_op) * jnp.cos(2 * jnp.pi * self.params[\"phi_sum_ext\"])\n        # H_nl_old += 2 * dEj * jqt.sinm(phi_op + 2 * jnp.pi * phi_delta_ext_op) * jnp.sin(2 * jnp.pi * self.params[\"phi_sum_ext\"]) \n        # H_nl_old += 2 * Ej2 * jqt.cosm(2*phi_op + 2 * 2 * jnp.pi * phi_delta_ext_op) * jnp.cos(2 * 2 * jnp.pi * self.params[\"phi_sum_ext\"])\n\n        return H_nl\n\n    def get_H_nonlinear(self, phi_op):\n        \"\"\"Return nonlinear terms in H.\"\"\"\n\n        Ej = self.params[\"Ej\"]\n        dEj = self.params[\"dEj\"]\n        Ej2 = self.params[\"Ej2\"]\n\n        phi_sum = self.params[\"phi_sum_ext\"]\n        phi_delta = self.params[\"phi_delta_ext\"]\n\n        return ATS.get_H_nonlinear_static(\n            phi_op, \n            Ej, \n            dEj, \n            Ej2, \n            phi_sum, \n            phi_delta\n        )\n\n\n    def get_H_full(self):\n        \"\"\"Return full H in linear basis.\"\"\"\n        id_op = self.linear_ops[\"id\"]\n        phi_b = self.linear_ops[\"phi\"]\n        H_nl = self.get_H_nonlinear(phi_b)\n        H = self.get_H_linear() + H_nl\n        return H\n\n    def potential(self, phi):\n        \"\"\"Return potential energy for a given phi.\"\"\"\n\n        phi_delta_ext = self.params[\"phi_delta_ext\"]\n        phi_sum_ext = self.params[\"phi_sum_ext\"]\n\n        V = 0.5 * self.params[\"El\"] * (2 * jnp.pi * phi) ** 2\n        V += - 2 * self.params[\"Ej\"] * jnp.cos(2 * jnp.pi * (phi + phi_delta_ext)) * jnp.cos(2 * jnp.pi * phi_sum_ext)\n        V += 2 * self.params[\"dEj\"] * jnp.sin(2 * jnp.pi * (phi + phi_delta_ext)) * jnp.sin(2 * jnp.pi * phi_sum_ext)\n        V += 2 * self.params[\"Ej2\"] * jnp.cos(2 * 2 * jnp.pi * (phi + phi_delta_ext)) * jnp.cos(2 * 2 * jnp.pi * phi_sum_ext)\n\n        return V\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.ATS.common_ops","title":"<code>common_ops()</code>","text":"<p>Written in the linear basis.</p> Source code in <code>qcsys/devices/ats.py</code> <pre><code>def common_ops(self):\n    \"\"\" Written in the linear basis. \"\"\"\n    ops = {}\n\n    N = self.N_pre_diag\n    ops[\"id\"] = jqt.identity(N)\n    ops[\"a\"] = jqt.destroy(N)\n    ops[\"a_dag\"] = jqt.create(N)\n    ops[\"phi\"] = self.phi_zpf()*(ops[\"a\"] + ops[\"a_dag\"])  \n    ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n    return ops\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.ATS.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in linear basis.</p> Source code in <code>qcsys/devices/ats.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in linear basis.\"\"\"\n    id_op = self.linear_ops[\"id\"]\n    phi_b = self.linear_ops[\"phi\"]\n    H_nl = self.get_H_nonlinear(phi_b)\n    H = self.get_H_linear() + H_nl\n    return H\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.ATS.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>qcsys/devices/ats.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_\u03c9()\n    return w*(self.linear_ops[\"a_dag\"]@self.linear_ops[\"a\"] + 0.5 * self.linear_ops[\"id\"])\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.ATS.get_H_nonlinear","title":"<code>get_H_nonlinear(phi_op)</code>","text":"<p>Return nonlinear terms in H.</p> Source code in <code>qcsys/devices/ats.py</code> <pre><code>def get_H_nonlinear(self, phi_op):\n    \"\"\"Return nonlinear terms in H.\"\"\"\n\n    Ej = self.params[\"Ej\"]\n    dEj = self.params[\"dEj\"]\n    Ej2 = self.params[\"Ej2\"]\n\n    phi_sum = self.params[\"phi_sum_ext\"]\n    phi_delta = self.params[\"phi_delta_ext\"]\n\n    return ATS.get_H_nonlinear_static(\n        phi_op, \n        Ej, \n        dEj, \n        Ej2, \n        phi_sum, \n        phi_delta\n    )\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.ATS.get_linear_\u03c9","title":"<code>get_linear_\u03c9()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>qcsys/devices/ats.py</code> <pre><code>def get_linear_\u03c9(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return jnp.sqrt(8*self.params[\"El\"]*self.params[\"Ec\"])\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.ATS.n_zpf","title":"<code>n_zpf()</code>","text":"<p>Return Charge ZPF.</p> Source code in <code>qcsys/devices/ats.py</code> <pre><code>def n_zpf(self):\n    \"\"\"Return Charge ZPF.\"\"\"\n    return (self.params[\"El\"]/(32*self.params[\"Ec\"]))**(.25)\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.ATS.phi_zpf","title":"<code>phi_zpf()</code>","text":"<p>Return Phase ZPF.</p> Source code in <code>qcsys/devices/ats.py</code> <pre><code>def phi_zpf(self):\n    \"\"\"Return Phase ZPF.\"\"\"\n    return (2*self.params[\"Ec\"]/self.params[\"El\"])**(.25)\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.ATS.potential","title":"<code>potential(phi)</code>","text":"<p>Return potential energy for a given phi.</p> Source code in <code>qcsys/devices/ats.py</code> <pre><code>def potential(self, phi):\n    \"\"\"Return potential energy for a given phi.\"\"\"\n\n    phi_delta_ext = self.params[\"phi_delta_ext\"]\n    phi_sum_ext = self.params[\"phi_sum_ext\"]\n\n    V = 0.5 * self.params[\"El\"] * (2 * jnp.pi * phi) ** 2\n    V += - 2 * self.params[\"Ej\"] * jnp.cos(2 * jnp.pi * (phi + phi_delta_ext)) * jnp.cos(2 * jnp.pi * phi_sum_ext)\n    V += 2 * self.params[\"dEj\"] * jnp.sin(2 * jnp.pi * (phi + phi_delta_ext)) * jnp.sin(2 * jnp.pi * phi_sum_ext)\n    V += 2 * self.params[\"Ej2\"] * jnp.cos(2 * 2 * jnp.pi * (phi + phi_delta_ext)) * jnp.cos(2 * 2 * jnp.pi * phi_sum_ext)\n\n    return V\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.Device","title":"<code>Device</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>qcsys/devices/base.py</code> <pre><code>@struct.dataclass\nclass Device(ABC):\n    N: int = struct.field(pytree_node=False)\n    N_pre_diag: int = struct.field(pytree_node=False)\n    params: Dict[str, Any]\n    _label: int = struct.field(pytree_node=False)\n    _basis: BasisTypes = struct.field(pytree_node=False)\n    _hamiltonian: HamiltonianTypes = struct.field(pytree_node=False)\n\n    @classmethod\n    def param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n        \"\"\" This can be overridden by subclasses.\"\"\"\n        pass\n\n    @classmethod\n    def create(cls, N, params, label=0, N_pre_diag=None,use_linear=False, hamiltonian: HamiltonianTypes = None, basis: BasisTypes = None):\n        \"\"\"Create a device.\n\n        Args:\n            N (int): dimension of Hilbert space.\n            params (dict): parameters of the device.\n            label (int, optional): label for the device. Defaults to 0. This is useful when you have multiple of the same device type in the same system.\n            N_pre_diag (int, optional): dimension of Hilbert space before diagonalization. Defaults to None, in which case it is set to N. This must be greater than or rqual to N.\n            use_linear (bool): whether to use the linearized device. Defaults to False. This will override the hamiltonian keyword argument. This is a bit redundant with hamiltonian, but it is kept for backwards compatibility.\n            hamiltonian (HamiltonianTypes, optional): type of Hamiltonian. Defaults to None, in which case the full hamiltonian is used.\n            basis (BasisTypes, optional): type of basis. Defaults to None, in which case the fock basis is used.\n        \"\"\"\n\n        if N_pre_diag is None:\n            N_pre_diag = N\n\n        assert N_pre_diag &gt;= N, \"N_pre_diag must be greater than or equal to N.\"\n\n        _basis = basis if basis is not None else BasisTypes.fock\n        _hamiltonian = hamiltonian if hamiltonian is not None else HamiltonianTypes.full\n        if use_linear:\n            _hamiltonian = HamiltonianTypes.linear\n\n        cls.param_validation(N, N_pre_diag, params, _hamiltonian, _basis)\n\n        return cls(N, N_pre_diag, params, label, _basis, _hamiltonian)\n\n    @property\n    def basis(self):\n        return self._basis\n\n    @property\n    def hamiltonian(self):\n        return self._hamiltonian\n\n    @property\n    def label(self):\n        return self.__class__.__name__ + str(self._label)\n\n    @property\n    def linear_ops(self):\n        return self.common_ops()\n\n    @property\n    def original_ops(self):\n        return self.common_ops()\n\n    @property\n    def ops(self):\n        return self.full_ops()\n\n    @abstractmethod\n    def common_ops(self) -&gt; Dict[str, jqt.Qarray]:\n        \"\"\"Set up common ops in the specified basis.\"\"\"\n\n    @abstractmethod\n    def get_linear_\u03c9(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n\n    @abstractmethod\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n\n    @abstractmethod\n    def get_H_full(self):\n        \"\"\"Return full H.\"\"\"\n\n    def get_H(self):\n        \"\"\"\n        Return diagonalized H. Explicitly keep only diagonal elements of matrix.\n        \"\"\"\n        return self.get_op_in_H_eigenbasis(self._get_H_in_original_basis()).keep_only_diag_elements()\n\n    def _get_H_in_original_basis(self):\n        \"\"\" This returns the Hamiltonian in the original specified basis. This can be overridden by subclasses.\"\"\"\n\n        if self.hamiltonian == HamiltonianTypes.linear:\n            return self.get_H_linear()\n        elif self.hamiltonian == HamiltonianTypes.full:\n            return self.get_H_full()\n\n    def _calculate_eig_systems(self):\n        evs, evecs = jnp.linalg.eigh(self._get_H_in_original_basis().data)  # Hermitian\n        idxs_sorted = jnp.argsort(evs)\n        return evs[idxs_sorted], evecs[:, idxs_sorted]\n\n    @property\n    def eig_systems(self):\n        eig_systems = {}\n        eig_systems[\"vals\"], eig_systems[\"vecs\"] = self._calculate_eig_systems()\n\n        eig_systems[\"vecs\"] = eig_systems[\"vecs\"]\n        eig_systems[\"vals\"] = eig_systems[\"vals\"]\n        return eig_systems\n\n    def get_op_in_H_eigenbasis(self, op: jqt.Qarray):\n        evecs = self.eig_systems[\"vecs\"][:, : self.N]\n        dims = [[self.N], [self.N]]\n        return get_op_in_new_basis(op, evecs, dims)\n\n    def get_op_data_in_H_eigenbasis(self, op: Array):\n        evecs = self.eig_systems[\"vecs\"][:, : self.N]\n        return get_op_data_in_new_basis(op, evecs)\n\n    def get_vec_in_H_eigenbasis(self, vec: jqt.Qarray):\n        evecs = self.eig_systems[\"vecs\"][:, : self.N]\n        if vec.qtype == jqt.Qtypes.ket:\n            dims = [[self.N],[1]]\n        else:\n            dims = [[1], [self.N]]\n        return get_vec_in_new_basis(vec, evecs, dims)\n\n    def get_vec_data_in_H_eigenbasis(self, vec: Array):\n        evecs = self.eig_systems[\"vecs\"][:, : self.N]\n        return get_vec_data_in_new_basis(vec, evecs)\n\n    def full_ops(self):\n        # TODO: use JAX vmap here\n\n        linear_ops = self.linear_ops\n        ops = {}\n        for name, op in linear_ops.items():\n            ops[name] = self.get_op_in_H_eigenbasis(op)\n\n        return ops\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.Device.common_ops","title":"<code>common_ops()</code>  <code>abstractmethod</code>","text":"<p>Set up common ops in the specified basis.</p> Source code in <code>qcsys/devices/base.py</code> <pre><code>@abstractmethod\ndef common_ops(self) -&gt; Dict[str, jqt.Qarray]:\n    \"\"\"Set up common ops in the specified basis.\"\"\"\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.Device.create","title":"<code>create(N, params, label=0, N_pre_diag=None, use_linear=False, hamiltonian=None, basis=None)</code>  <code>classmethod</code>","text":"<p>Create a device.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>dimension of Hilbert space.</p> required <code>params</code> <code>dict</code> <p>parameters of the device.</p> required <code>label</code> <code>int</code> <p>label for the device. Defaults to 0. This is useful when you have multiple of the same device type in the same system.</p> <code>0</code> <code>N_pre_diag</code> <code>int</code> <p>dimension of Hilbert space before diagonalization. Defaults to None, in which case it is set to N. This must be greater than or rqual to N.</p> <code>None</code> <code>use_linear</code> <code>bool</code> <p>whether to use the linearized device. Defaults to False. This will override the hamiltonian keyword argument. This is a bit redundant with hamiltonian, but it is kept for backwards compatibility.</p> <code>False</code> <code>hamiltonian</code> <code>HamiltonianTypes</code> <p>type of Hamiltonian. Defaults to None, in which case the full hamiltonian is used.</p> <code>None</code> <code>basis</code> <code>BasisTypes</code> <p>type of basis. Defaults to None, in which case the fock basis is used.</p> <code>None</code> Source code in <code>qcsys/devices/base.py</code> <pre><code>@classmethod\ndef create(cls, N, params, label=0, N_pre_diag=None,use_linear=False, hamiltonian: HamiltonianTypes = None, basis: BasisTypes = None):\n    \"\"\"Create a device.\n\n    Args:\n        N (int): dimension of Hilbert space.\n        params (dict): parameters of the device.\n        label (int, optional): label for the device. Defaults to 0. This is useful when you have multiple of the same device type in the same system.\n        N_pre_diag (int, optional): dimension of Hilbert space before diagonalization. Defaults to None, in which case it is set to N. This must be greater than or rqual to N.\n        use_linear (bool): whether to use the linearized device. Defaults to False. This will override the hamiltonian keyword argument. This is a bit redundant with hamiltonian, but it is kept for backwards compatibility.\n        hamiltonian (HamiltonianTypes, optional): type of Hamiltonian. Defaults to None, in which case the full hamiltonian is used.\n        basis (BasisTypes, optional): type of basis. Defaults to None, in which case the fock basis is used.\n    \"\"\"\n\n    if N_pre_diag is None:\n        N_pre_diag = N\n\n    assert N_pre_diag &gt;= N, \"N_pre_diag must be greater than or equal to N.\"\n\n    _basis = basis if basis is not None else BasisTypes.fock\n    _hamiltonian = hamiltonian if hamiltonian is not None else HamiltonianTypes.full\n    if use_linear:\n        _hamiltonian = HamiltonianTypes.linear\n\n    cls.param_validation(N, N_pre_diag, params, _hamiltonian, _basis)\n\n    return cls(N, N_pre_diag, params, label, _basis, _hamiltonian)\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.Device.get_H","title":"<code>get_H()</code>","text":"<p>Return diagonalized H. Explicitly keep only diagonal elements of matrix.</p> Source code in <code>qcsys/devices/base.py</code> <pre><code>def get_H(self):\n    \"\"\"\n    Return diagonalized H. Explicitly keep only diagonal elements of matrix.\n    \"\"\"\n    return self.get_op_in_H_eigenbasis(self._get_H_in_original_basis()).keep_only_diag_elements()\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.Device.get_H_full","title":"<code>get_H_full()</code>  <code>abstractmethod</code>","text":"<p>Return full H.</p> Source code in <code>qcsys/devices/base.py</code> <pre><code>@abstractmethod\ndef get_H_full(self):\n    \"\"\"Return full H.\"\"\"\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.Device.get_H_linear","title":"<code>get_H_linear()</code>  <code>abstractmethod</code>","text":"<p>Return linear terms in H.</p> Source code in <code>qcsys/devices/base.py</code> <pre><code>@abstractmethod\ndef get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.Device.get_linear_\u03c9","title":"<code>get_linear_\u03c9()</code>  <code>abstractmethod</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>qcsys/devices/base.py</code> <pre><code>@abstractmethod\ndef get_linear_\u03c9(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.Device.param_validation","title":"<code>param_validation(N, N_pre_diag, params, hamiltonian, basis)</code>  <code>classmethod</code>","text":"<p>This can be overridden by subclasses.</p> Source code in <code>qcsys/devices/base.py</code> <pre><code>@classmethod\ndef param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n    \"\"\" This can be overridden by subclasses.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.Drive","title":"<code>Drive</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>qcsys/devices/drive.py</code> <pre><code>@struct.dataclass\nclass Drive(ABC):\n    N: int = struct.field(pytree_node=False)\n    \u03c9d: float\n    _label: int = struct.field(pytree_node=False)\n\n    @classmethod\n    def create(cls, M_max, \u03c9d, label=0):\n        cls.M_max = M_max\n        N = 2 * M_max + 1\n        return cls(N, \u03c9d, label)\n\n    @property\n    def label(self):\n        return self.__class__.__name__ + str(self._label)\n\n    @property\n    def ops(self):\n        return self.common_ops()\n\n    def common_ops(self) -&gt; Dict[str, jqt.Qarray]:\n        ops = {}\n\n        M_max = self.M_max\n\n        # Construct M = \u2211\u2098 m|m&gt;&lt;m| operator in drive charge basis\n        ops[\"M\"] = jqt.jnp2jqt(jnp.diag(jnp.arange(-M_max, M_max + 1)))\n\n        # Construct Id = \u2211\u2098|m&gt;&lt;m| in the drive charge basis\n        ops[\"id\"] = jqt.jnp2jqt(jnp.identity(2 * M_max + 1))\n\n        # Construct M\u208a \u2261 exp(i\u03b8) and M\u208b \u2261 exp(-i\u03b8) operators for drive\n        ops[\"M-\"] = jqt.jnp2jqt(jnp.eye(2 * M_max + 1, k=1))\n        ops[\"M+\"] = jqt.jnp2jqt(jnp.eye(2 * M_max + 1, k=-1))\n\n        # Construct cos(\u03b8) \u2261 1/2 * [M\u208a + M\u208b] = 1/2 * \u2211\u2098|m+1&gt;&lt;m| + h.c\n        ops[\"cos(\u03b8)\"] = 0.5 * (ops[\"M+\"] + ops[\"M-\"])\n\n        # Construct sin(\u03b8) \u2261 -i/2 * [M\u208a - M\u208b] = -i/2 * \u2211\u2098|m+1&gt;&lt;m| + h.c\n        ops[\"sin(\u03b8)\"] = -0.5j * (ops[\"M+\"] - ops[\"M-\"])\n\n        # Construct more general drive operators cos(k\u03b8) and sin(k\u03b8)\n        for k in range(2, M_max + 1):\n            ops[f\"M_+{k}\"] = jqt.jnp2jqt(jnp.eye(2 * M_max + 1, k=-k))\n            ops[f\"M_-{k}\"] = jqt.jnp2jqt(jnp.eye(2 * M_max + 1, k=k))\n            ops[f\"cos({k}\u03b8)\"] = 0.5 * (ops[f\"M_+{k}\"] + ops[f\"M_-{k}\"])\n            ops[f\"sin({k}\u03b8)\"] = -0.5j * (ops[f\"M_+{k}\"] - ops[f\"M_-{k}\"])\n\n        return ops\n\n    #############################################################\n\n    def get_H(self):\n        \"\"\"\n        Bare \"drive\" Hamiltonian (\u03c9d * M) in the extended Hilbert space.\n        \"\"\"\n        return self.\u03c9d * self.ops[\"M\"]\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.Drive.get_H","title":"<code>get_H()</code>","text":"<p>Bare \"drive\" Hamiltonian (\u03c9d * M) in the extended Hilbert space.</p> Source code in <code>qcsys/devices/drive.py</code> <pre><code>def get_H(self):\n    \"\"\"\n    Bare \"drive\" Hamiltonian (\u03c9d * M) in the extended Hilbert space.\n    \"\"\"\n    return self.\u03c9d * self.ops[\"M\"]\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.FluxDevice","title":"<code>FluxDevice</code>","text":"<p>               Bases: <code>Device</code></p> Source code in <code>qcsys/devices/base.py</code> <pre><code>@struct.dataclass\nclass FluxDevice(Device):\n    @abstractmethod\n    def phi_zpf(self):\n        \"\"\"Return Phase ZPF.\"\"\"\n\n    def _calculate_wavefunctions_fock(self, phi_vals):\n        \"\"\"Calculate wavefunctions at phi_exts.\"\"\"\n        phi_osc = self.phi_zpf() * jnp.sqrt(2) # length of oscillator\n        phi_vals = jnp.array(phi_vals)\n\n        # calculate basis functions\n        basis_functions = []\n        for n in range(self.N_pre_diag):\n            basis_functions.append(\n                harm_osc_wavefunction(n, phi_vals, jnp.real(phi_osc))\n            )\n        basis_functions = jnp.array(basis_functions)\n\n        # transform to better diagonal basis\n        basis_functions_in_H_eigenbasis = self.get_vec_data_in_H_eigenbasis(basis_functions)\n\n        # the below is equivalent to evecs_in_H_eigenbasis @ basis_functions_in_H_eigenbasis\n        # since evecs in H_eigenbasis is diagonal, i.e. the identity matrix\n        wavefunctions = basis_functions_in_H_eigenbasis \n        return wavefunctions\n\n    def _calculate_wavefunctions_charge(self, phi_vals):\n        phi_vals = jnp.array(phi_vals)\n\n        # calculate basis functions\n        basis_functions = []\n        n_max = (self.N_pre_diag - 1) // 2\n        for n in jnp.arange(-n_max, n_max + 1):\n            basis_functions.append(\n                1/(jnp.sqrt(2*jnp.pi)) * jnp.exp(1j * n * (2*jnp.pi*phi_vals))\n            )\n        basis_functions = jnp.array(basis_functions)\n\n        # transform to better diagonal basis\n        basis_functions_in_H_eigenbasis = self.get_vec_data_in_H_eigenbasis(basis_functions)\n\n        # the below is equivalent to evecs_in_H_eigenbasis @ basis_functions_in_H_eigenbasis\n        # since evecs in H_eigenbasis is diagonal, i.e. the identity matrix\n        phase_correction_factors =  (1j**(jnp.arange(0,self.N_pre_diag))).reshape(self.N_pre_diag,1) # TODO: review why these are needed...\n        wavefunctions = basis_functions_in_H_eigenbasis * phase_correction_factors\n        return wavefunctions\n\n    @abstractmethod\n    def potential(self, phi):\n        \"\"\"Return potential energy as a function of phi.\"\"\"\n\n    def plot_wavefunctions(self, phi_vals, max_n=None, which=None, ax=None, mode=\"abs\"):\n\n        if self.basis == BasisTypes.fock:\n            _calculate_wavefunctions = self._calculate_wavefunctions_fock\n        elif self.basis == BasisTypes.charge:\n            _calculate_wavefunctions = self._calculate_wavefunctions_charge\n        else:\n            raise NotImplementedError(f\"The {self.basis} is not yet supported for plotting wavefunctions.\")\n\n        \"\"\"Plot wavefunctions at phi_exts.\"\"\"\n        wavefunctions = _calculate_wavefunctions(phi_vals)\n        energy_levels = self.eig_systems[\"vals\"][:self.N]\n\n        potential = self.potential(phi_vals)\n\n        if ax is None:\n            fig, ax = plt.subplots(1,1, figsize = (3.5, 2.5), dpi = 1000)\n        else:\n            fig = ax.get_figure()\n\n        min_val = None\n        max_val = None\n\n        assert max_n is None or which is None, \"Can't specify both max_n and which\"\n\n        max_n = self.N if max_n is None else max_n\n        levels = range(max_n) if which is None else which\n\n        for n in levels:\n            if mode == \"abs\":\n                wf_vals = jnp.abs(wavefunctions[n, :])**2\n            elif mode == \"real\":\n                wf_vals = wavefunctions[n, :].real\n            elif mode == \"imag\":\n                wf_vals = wavefunctions[n, :].imag\n\n            wf_vals += energy_levels[n]\n            curr_min_val = min(wf_vals)\n            curr_max_val = max(wf_vals)\n\n            if min_val is None or curr_min_val &lt; min_val:\n                min_val = curr_min_val\n\n            if max_val is None or curr_max_val &gt; max_val:\n                max_val = curr_max_val\n\n            ax.plot(phi_vals, wf_vals, label=f\"$|${n}$\\\\rangle$\", linestyle = '-', linewidth = 1)\n            ax.fill_between(phi_vals, energy_levels[n], wf_vals, alpha=0.5)\n\n        ax.plot(phi_vals, potential, label=\"potential\", color=\"black\", linestyle = '-', linewidth = 1)\n\n        ax.set_ylim([min_val-1, max_val+1])\n\n        ax.set_xlabel(r\"$\\Phi/\\Phi_0$\")\n        ax.set_ylabel(r\"Energy [GHz]\")\n\n        if mode == \"abs\":\n            title_str = r\"$|\\psi_n(\\Phi)|^2$\"\n        elif mode == \"real\":\n            title_str = r\"Re($\\psi_n(\\Phi)$)\"\n        elif mode == \"imag\":\n            title_str = r\"Im($\\psi_n(\\Phi)$)\"\n\n        ax.set_title(f\"{title_str}\")\n\n        plt.legend(fontsize=6)\n        fig.tight_layout()\n\n        return ax\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.FluxDevice.phi_zpf","title":"<code>phi_zpf()</code>  <code>abstractmethod</code>","text":"<p>Return Phase ZPF.</p> Source code in <code>qcsys/devices/base.py</code> <pre><code>@abstractmethod\ndef phi_zpf(self):\n    \"\"\"Return Phase ZPF.\"\"\"\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.FluxDevice.potential","title":"<code>potential(phi)</code>  <code>abstractmethod</code>","text":"<p>Return potential energy as a function of phi.</p> Source code in <code>qcsys/devices/base.py</code> <pre><code>@abstractmethod\ndef potential(self, phi):\n    \"\"\"Return potential energy as a function of phi.\"\"\"\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.Fluxonium","title":"<code>Fluxonium</code>","text":"<p>               Bases: <code>FluxDevice</code></p> <p>Fluxonium Device.</p> Source code in <code>qcsys/devices/fluxonium.py</code> <pre><code>@struct.dataclass\nclass Fluxonium(FluxDevice):\n    \"\"\"\n    Fluxonium Device.\n    \"\"\"\n\n    def common_ops(self):\n        \"\"\" Written in the linear basis. \"\"\"\n        ops = {}\n\n        N = self.N_pre_diag\n        ops[\"id\"] = jqt.identity(N)\n        ops[\"a\"] = jqt.destroy(N)\n        ops[\"a_dag\"] = jqt.create(N)\n        ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n        ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n        ops[\"cos(\u03c6/2)\"] = jqt.cosm(ops[\"phi\"] / 2)\n        ops[\"sin(\u03c6/2)\"] = jqt.sinm(ops[\"phi\"] / 2)\n\n        return ops\n\n    def n_zpf(self):\n        n_zpf = (self.params[\"El\"] / (32.0 * self.params[\"Ec\"])) ** (0.25)\n        return n_zpf\n\n    def phi_zpf(self):\n        \"\"\"Return Phase ZPF.\"\"\"\n        return (2 * self.params[\"Ec\"] / self.params[\"El\"]) ** (0.25)\n\n    def get_linear_\u03c9(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return jnp.sqrt(8 * self.params[\"Ec\"] * self.params[\"El\"])\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_\u03c9()\n        return w * (\n            self.linear_ops[\"a_dag\"] @ self.linear_ops[\"a\"]\n            + 0.5 * self.linear_ops[\"id\"]\n        )\n\n    def get_H_full(self):\n        \"\"\"Return full H in linear basis.\"\"\"\n\n        phi_op = self.linear_ops[\"phi\"]\n        return self.get_H_linear() + self.get_H_nonlinear(phi_op)\n\n    def get_H_nonlinear(self, phi_op):\n        op_cos_phi = jqt.cosm(phi_op)\n        op_sin_phi = jqt.sinm(phi_op)\n\n        phi_ext = self.params[\"phi_ext\"]\n        Hcos = op_cos_phi * jnp.cos(2.0 * jnp.pi * phi_ext) + op_sin_phi * jnp.sin(\n            2.0 * jnp.pi * phi_ext\n        )\n        H_nl = - self.params[\"Ej\"] * Hcos\n        return H_nl\n\n    def potential(self, phi):\n        \"\"\"Return potential energy for a given phi.\"\"\"\n        phi_ext = self.params[\"phi_ext\"]\n        V_linear = 0.5 * self.params[\"El\"] * (2 * jnp.pi * phi) ** 2\n\n        if self.hamiltonian == HamiltonianTypes.linear:\n            return V_linear\n\n        V_nonlinear = -self.params[\"Ej\"] * jnp.cos(2.0 * jnp.pi * (phi - phi_ext))\n        if self.hamiltonian == HamiltonianTypes.full:\n            return V_linear + V_nonlinear\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.Fluxonium.common_ops","title":"<code>common_ops()</code>","text":"<p>Written in the linear basis.</p> Source code in <code>qcsys/devices/fluxonium.py</code> <pre><code>def common_ops(self):\n    \"\"\" Written in the linear basis. \"\"\"\n    ops = {}\n\n    N = self.N_pre_diag\n    ops[\"id\"] = jqt.identity(N)\n    ops[\"a\"] = jqt.destroy(N)\n    ops[\"a_dag\"] = jqt.create(N)\n    ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n    ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n    ops[\"cos(\u03c6/2)\"] = jqt.cosm(ops[\"phi\"] / 2)\n    ops[\"sin(\u03c6/2)\"] = jqt.sinm(ops[\"phi\"] / 2)\n\n    return ops\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.Fluxonium.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in linear basis.</p> Source code in <code>qcsys/devices/fluxonium.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in linear basis.\"\"\"\n\n    phi_op = self.linear_ops[\"phi\"]\n    return self.get_H_linear() + self.get_H_nonlinear(phi_op)\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.Fluxonium.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>qcsys/devices/fluxonium.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_\u03c9()\n    return w * (\n        self.linear_ops[\"a_dag\"] @ self.linear_ops[\"a\"]\n        + 0.5 * self.linear_ops[\"id\"]\n    )\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.Fluxonium.get_linear_\u03c9","title":"<code>get_linear_\u03c9()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>qcsys/devices/fluxonium.py</code> <pre><code>def get_linear_\u03c9(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return jnp.sqrt(8 * self.params[\"Ec\"] * self.params[\"El\"])\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.Fluxonium.phi_zpf","title":"<code>phi_zpf()</code>","text":"<p>Return Phase ZPF.</p> Source code in <code>qcsys/devices/fluxonium.py</code> <pre><code>def phi_zpf(self):\n    \"\"\"Return Phase ZPF.\"\"\"\n    return (2 * self.params[\"Ec\"] / self.params[\"El\"]) ** (0.25)\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.Fluxonium.potential","title":"<code>potential(phi)</code>","text":"<p>Return potential energy for a given phi.</p> Source code in <code>qcsys/devices/fluxonium.py</code> <pre><code>def potential(self, phi):\n    \"\"\"Return potential energy for a given phi.\"\"\"\n    phi_ext = self.params[\"phi_ext\"]\n    V_linear = 0.5 * self.params[\"El\"] * (2 * jnp.pi * phi) ** 2\n\n    if self.hamiltonian == HamiltonianTypes.linear:\n        return V_linear\n\n    V_nonlinear = -self.params[\"Ej\"] * jnp.cos(2.0 * jnp.pi * (phi - phi_ext))\n    if self.hamiltonian == HamiltonianTypes.full:\n        return V_linear + V_nonlinear\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.IdealQubit","title":"<code>IdealQubit</code>","text":"<p>               Bases: <code>Device</code></p> <p>Ideal qubit Device.</p> Source code in <code>qcsys/devices/ideal_qubit.py</code> <pre><code>@struct.dataclass\nclass IdealQubit(Device):\n    \"\"\"\n    Ideal qubit Device.\n    \"\"\"\n\n    @classmethod\n    def param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n        \"\"\" This can be overridden by subclasses.\"\"\"\n        assert basis == BasisTypes.fock, \"IdealQubit is a two-level system defined in the Fock basis.\" \n        assert hamiltonian == HamiltonianTypes.full, \"IdealQubit requires a full Hamiltonian.\"\n        assert N == N_pre_diag == 2, \"IdealQubit is a two-level system.\"\n        assert \"\u03c9\" in params, \"IdealQubit requires a frequency parameter '\u03c9'.\"\n\n    def common_ops(self):\n        \"\"\"Written in the linear basis.\"\"\"\n        ops = {}\n\n        assert self.N_pre_diag == 2\n        assert self.N == 2\n\n        N = self.N_pre_diag\n        ops[\"id\"] = jqt.identity(N)\n        ops[\"sigmaz\"] = jqt.sigmaz()\n        ops[\"sigmax\"] = jqt.sigmax()\n        ops[\"sigmay\"] = jqt.sigmay()\n        ops[\"sigmam\"] = jqt.sigmam()\n        ops[\"sigmap\"] = jqt.sigmap()\n\n        return ops\n\n    def get_linear_\u03c9(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return self.params[\"\u03c9\"]\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_\u03c9()\n        return (w / 2) * self.linear_ops[\"sigma_z\"]\n\n    def get_H_full(self):\n        \"\"\"Return full H in linear basis.\"\"\"\n        return self.get_H_linear()\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.IdealQubit.common_ops","title":"<code>common_ops()</code>","text":"<p>Written in the linear basis.</p> Source code in <code>qcsys/devices/ideal_qubit.py</code> <pre><code>def common_ops(self):\n    \"\"\"Written in the linear basis.\"\"\"\n    ops = {}\n\n    assert self.N_pre_diag == 2\n    assert self.N == 2\n\n    N = self.N_pre_diag\n    ops[\"id\"] = jqt.identity(N)\n    ops[\"sigmaz\"] = jqt.sigmaz()\n    ops[\"sigmax\"] = jqt.sigmax()\n    ops[\"sigmay\"] = jqt.sigmay()\n    ops[\"sigmam\"] = jqt.sigmam()\n    ops[\"sigmap\"] = jqt.sigmap()\n\n    return ops\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.IdealQubit.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in linear basis.</p> Source code in <code>qcsys/devices/ideal_qubit.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in linear basis.\"\"\"\n    return self.get_H_linear()\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.IdealQubit.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>qcsys/devices/ideal_qubit.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_\u03c9()\n    return (w / 2) * self.linear_ops[\"sigma_z\"]\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.IdealQubit.get_linear_\u03c9","title":"<code>get_linear_\u03c9()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>qcsys/devices/ideal_qubit.py</code> <pre><code>def get_linear_\u03c9(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return self.params[\"\u03c9\"]\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.IdealQubit.param_validation","title":"<code>param_validation(N, N_pre_diag, params, hamiltonian, basis)</code>  <code>classmethod</code>","text":"<p>This can be overridden by subclasses.</p> Source code in <code>qcsys/devices/ideal_qubit.py</code> <pre><code>@classmethod\ndef param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n    \"\"\" This can be overridden by subclasses.\"\"\"\n    assert basis == BasisTypes.fock, \"IdealQubit is a two-level system defined in the Fock basis.\" \n    assert hamiltonian == HamiltonianTypes.full, \"IdealQubit requires a full Hamiltonian.\"\n    assert N == N_pre_diag == 2, \"IdealQubit is a two-level system.\"\n    assert \"\u03c9\" in params, \"IdealQubit requires a frequency parameter '\u03c9'.\"\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.KNO","title":"<code>KNO</code>","text":"<p>               Bases: <code>Device</code></p> <p>Kerr Nonlinear Oscillator Device.</p> Source code in <code>qcsys/devices/kno.py</code> <pre><code>@struct.dataclass\nclass KNO(Device):\n    \"\"\"\n    Kerr Nonlinear Oscillator Device.\n    \"\"\"\n\n    @classmethod\n    def param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n        \"\"\" This can be overridden by subclasses.\"\"\"\n        assert basis == BasisTypes.fock, \"Kerr Nonlinear Oscillator must be defined in the Fock basis.\" \n        assert hamiltonian == HamiltonianTypes.full, \"Kerr Nonlinear Oscillator uses a full Hamiltonian.\"\n        assert \"\u03c9\" in params and \"\u03b1\" in params, \"Kerr Nonlinear Oscillator requires frequency '\u03c9' and anharmonicity '\u03b1' as parameters.\"\n\n    def common_ops(self):\n        ops = {}\n\n        N = self.N\n        ops[\"id\"] = jqt.identity(N)\n        ops[\"a\"] = jqt.destroy(N)\n        ops[\"a_dag\"] = jqt.create(N)\n        ops[\"phi\"] = (ops[\"a\"] + ops[\"a_dag\"]) / jnp.sqrt(2)\n        ops[\"n\"] = 1j * (ops[\"a_dag\"] - ops[\"a\"]) / jnp.sqrt(2)\n        return ops\n\n    def get_linear_\u03c9(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return self.params[\"\u03c9\"]\n\n    def get_anharm(self):\n        \"\"\"Get anharmonicity.\"\"\"\n        return self.params[\"\u03b1\"]\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_\u03c9()\n        return w * self.linear_ops[\"a_dag\"] @ self.linear_ops[\"a\"]\n\n    def get_H_full(self):\n        \"\"\"Return full H in linear basis.\"\"\"\n        \u03b1 = self.get_anharm()\n\n        return self.get_H_linear() + (\u03b1 / 2) * (\n            self.linear_ops[\"a_dag\"]\n            @ self.linear_ops[\"a_dag\"]\n            @ self.linear_ops[\"a\"]\n            @ self.linear_ops[\"a\"]\n        )\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.KNO.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in linear basis.</p> Source code in <code>qcsys/devices/kno.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in linear basis.\"\"\"\n    \u03b1 = self.get_anharm()\n\n    return self.get_H_linear() + (\u03b1 / 2) * (\n        self.linear_ops[\"a_dag\"]\n        @ self.linear_ops[\"a_dag\"]\n        @ self.linear_ops[\"a\"]\n        @ self.linear_ops[\"a\"]\n    )\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.KNO.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>qcsys/devices/kno.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_\u03c9()\n    return w * self.linear_ops[\"a_dag\"] @ self.linear_ops[\"a\"]\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.KNO.get_anharm","title":"<code>get_anharm()</code>","text":"<p>Get anharmonicity.</p> Source code in <code>qcsys/devices/kno.py</code> <pre><code>def get_anharm(self):\n    \"\"\"Get anharmonicity.\"\"\"\n    return self.params[\"\u03b1\"]\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.KNO.get_linear_\u03c9","title":"<code>get_linear_\u03c9()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>qcsys/devices/kno.py</code> <pre><code>def get_linear_\u03c9(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return self.params[\"\u03c9\"]\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.KNO.param_validation","title":"<code>param_validation(N, N_pre_diag, params, hamiltonian, basis)</code>  <code>classmethod</code>","text":"<p>This can be overridden by subclasses.</p> Source code in <code>qcsys/devices/kno.py</code> <pre><code>@classmethod\ndef param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n    \"\"\" This can be overridden by subclasses.\"\"\"\n    assert basis == BasisTypes.fock, \"Kerr Nonlinear Oscillator must be defined in the Fock basis.\" \n    assert hamiltonian == HamiltonianTypes.full, \"Kerr Nonlinear Oscillator uses a full Hamiltonian.\"\n    assert \"\u03c9\" in params and \"\u03b1\" in params, \"Kerr Nonlinear Oscillator requires frequency '\u03c9' and anharmonicity '\u03b1' as parameters.\"\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.Resonator","title":"<code>Resonator</code>","text":"<p>               Bases: <code>FluxDevice</code></p> <p>Resonator Device.</p> Source code in <code>qcsys/devices/resonator.py</code> <pre><code>@struct.dataclass\nclass Resonator(FluxDevice):        \n    \"\"\"\n    Resonator Device.\n    \"\"\"\n\n    def common_ops(self):\n        \"\"\" Written in the linear basis. \"\"\"\n        ops = {}\n\n        N = self.N_pre_diag\n        ops[\"id\"] = jqt.identity(N)\n        ops[\"a\"] = jqt.destroy(N)\n        ops[\"a_dag\"] = jqt.create(N)\n        ops[\"phi\"] = self.phi_zpf()*(ops[\"a\"] + ops[\"a_dag\"])  \n        ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n        return ops\n\n    def phi_zpf(self):\n        \"\"\"Return Phase ZPF.\"\"\"\n        return (2*self.params[\"Ec\"]/self.params[\"El\"])**(.25)\n\n    def n_zpf(self):\n        n_zpf = (self.params[\"El\"] / (32.0 * self.params[\"Ec\"])) ** (0.25)\n        return n_zpf\n\n    def get_linear_\u03c9(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return jnp.sqrt(8*self.params[\"El\"]*self.params[\"Ec\"])\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_\u03c9()\n        return w*(self.linear_ops[\"a_dag\"]@self.linear_ops[\"a\"] + 1/2)\n\n    def get_H_full(self):\n        \"\"\"Return full H in linear basis.\"\"\"\n        return self.get_H_linear()\n\n    def potential(self, phi):\n        \"\"\"Return potential energy for a given phi.\"\"\"\n        return 0.5 * self.params[\"El\"] * (2 * jnp.pi * phi) ** 2\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.Resonator.common_ops","title":"<code>common_ops()</code>","text":"<p>Written in the linear basis.</p> Source code in <code>qcsys/devices/resonator.py</code> <pre><code>def common_ops(self):\n    \"\"\" Written in the linear basis. \"\"\"\n    ops = {}\n\n    N = self.N_pre_diag\n    ops[\"id\"] = jqt.identity(N)\n    ops[\"a\"] = jqt.destroy(N)\n    ops[\"a_dag\"] = jqt.create(N)\n    ops[\"phi\"] = self.phi_zpf()*(ops[\"a\"] + ops[\"a_dag\"])  \n    ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n    return ops\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.Resonator.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in linear basis.</p> Source code in <code>qcsys/devices/resonator.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in linear basis.\"\"\"\n    return self.get_H_linear()\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.Resonator.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>qcsys/devices/resonator.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_\u03c9()\n    return w*(self.linear_ops[\"a_dag\"]@self.linear_ops[\"a\"] + 1/2)\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.Resonator.get_linear_\u03c9","title":"<code>get_linear_\u03c9()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>qcsys/devices/resonator.py</code> <pre><code>def get_linear_\u03c9(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return jnp.sqrt(8*self.params[\"El\"]*self.params[\"Ec\"])\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.Resonator.phi_zpf","title":"<code>phi_zpf()</code>","text":"<p>Return Phase ZPF.</p> Source code in <code>qcsys/devices/resonator.py</code> <pre><code>def phi_zpf(self):\n    \"\"\"Return Phase ZPF.\"\"\"\n    return (2*self.params[\"Ec\"]/self.params[\"El\"])**(.25)\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.Resonator.potential","title":"<code>potential(phi)</code>","text":"<p>Return potential energy for a given phi.</p> Source code in <code>qcsys/devices/resonator.py</code> <pre><code>def potential(self, phi):\n    \"\"\"Return potential energy for a given phi.\"\"\"\n    return 0.5 * self.params[\"El\"] * (2 * jnp.pi * phi) ** 2\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.Transmon","title":"<code>Transmon</code>","text":"<p>               Bases: <code>FluxDevice</code></p> <p>Transmon Device.</p> Source code in <code>qcsys/devices/transmon.py</code> <pre><code>@struct.dataclass\nclass Transmon(FluxDevice):\n    \"\"\"\n    Transmon Device.\n    \"\"\"\n\n    @classmethod\n    def param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n        \"\"\" This can be overridden by subclasses.\"\"\"\n        if hamiltonian == HamiltonianTypes.linear:\n            assert basis == BasisTypes.fock, \"Linear Hamiltonian only works with Fock basis.\"\n        elif hamiltonian == HamiltonianTypes.truncated:\n            assert basis == BasisTypes.fock, \"Truncated Hamiltonian only works with Fock basis.\"\n        elif hamiltonian == HamiltonianTypes.full:\n            assert basis in [BasisTypes.charge, BasisTypes.single_charge], \"Full Hamiltonian only works with Cooper pair charge or single-electron charge bases.\"\n\n        # Set the gate offset charge to zero if not provided\n        if \"ng\" not in params:\n            params[\"ng\"] = 0.0\n\n        assert (N_pre_diag - 1) % 2 == 0, \"N_pre_diag must be odd.\"\n\n    def common_ops(self):\n        \"\"\" Written in the specified basis. \"\"\"\n\n        ops = {}\n\n        N = self.N_pre_diag\n\n        if self.basis == BasisTypes.fock:\n            ops[\"id\"] = jqt.identity(N)\n            ops[\"a\"] = jqt.destroy(N)\n            ops[\"a_dag\"] = jqt.create(N)\n            ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n            ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n        elif self.basis == BasisTypes.charge:\n            \"\"\"\n            Here H = 4 * Ec (n - ng)\u00b2 - Ej cos(\u03c6) in the Cooper pair charge basis. \n            \"\"\"\n            ops[\"id\"] = jqt.identity(N)\n            ops[\"cos(\u03c6)\"] = 0.5*(jqt.jnp2jqt(jnp.eye(N,k=1) + jnp.eye(N,k=-1)))\n            ops[\"sin(\u03c6)\"] = 0.5j*(jqt.jnp2jqt(jnp.eye(N,k=1) - jnp.eye(N,k=-1)))\n            n_max = (N - 1) // 2\n            ops[\"n\"] = jqt.jnp2jqt(jnp.diag(jnp.arange(-n_max, n_max + 1)))\n\n            n_minus_ng_array = jnp.arange(-n_max, n_max + 1) - self.params[\"ng\"] * jnp.ones(N)\n            ops[\"H_charge\"] = jqt.jnp2jqt(jnp.diag(4 * self.params[\"Ec\"] * n_minus_ng_array**2))\n\n        elif self.basis == BasisTypes.single_charge:\n            \"\"\"\n            Here H = Ec (n - 2ng)\u00b2 - Ej cos(\u03c6) in the single-electron charge basis. Using Eq. (5.36) of Kyle Serniak's\n            thesis, we have H = Ec \u2211\u2099(n - 2*ng) |n\u27e9\u27e8n| - Ej/2 * \u2211\u2099|n\u27e9\u27e8n+2| + h.c where n counts the number of electrons, \n            not Cooper pairs. Note, we use 2ng instead of ng to match the gate offset charge convention of the transmon \n            (as done in Kyle's thesis).\n            \"\"\"\n            n_max = (N - 1) // 2\n\n            ops[\"id\"] = jqt.identity(N)\n            ops[\"cos(\u03c6)\"] = 0.5*(jqt.jnp2jqt(jnp.eye(N,k=2) + jnp.eye(N,k=-2)))\n            ops[\"sin(\u03c6)\"] = 0.5j*(jqt.jnp2jqt(jnp.eye(N,k=2) - jnp.eye(N,k=-2)))\n            ops[\"cos(\u03c6/2)\"] = 0.5*(jqt.jnp2jqt(jnp.eye(N,k=1) + jnp.eye(N,k=-1)))\n            ops[\"sin(\u03c6/2)\"] = 0.5j*(jqt.jnp2jqt(jnp.eye(N,k=1) - jnp.eye(N,k=-1)))\n            ops[\"n\"] = jqt.jnp2jqt(jnp.diag(jnp.arange(-n_max, n_max + 1)))\n\n            n_minus_ng_array = jnp.arange(-n_max, n_max + 1) - 2 * self.params[\"ng\"] * jnp.ones(N)\n            ops[\"H_charge\"] = jqt.jnp2jqt(jnp.diag(self.params[\"Ec\"] * n_minus_ng_array**2))\n\n        return ops\n\n    @property\n    def Ej(self):\n        return self.params[\"Ej\"]\n\n    def phi_zpf(self):\n        \"\"\"Return Phase ZPF.\"\"\"\n        return (2 * self.params[\"Ec\"] / self.Ej) ** (0.25)\n\n    def n_zpf(self):\n        \"\"\"Return Charge ZPF.\"\"\"\n        return (self.Ej / (32 * self.params[\"Ec\"])) ** (0.25)\n\n    def get_linear_\u03c9(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return jnp.sqrt(8 * self.params[\"Ec\"] * self.Ej)\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_\u03c9()\n        return w * self.original_ops[\"a_dag\"] @ self.original_ops[\"a\"]\n\n    def get_H_full(self):\n        \"\"\"Return full H in specified basis.\"\"\"\n        return self.original_ops[\"H_charge\"] - self.Ej * self.original_ops[\"cos(\u03c6)\"]\n\n    def get_H_truncated(self):\n        \"\"\"Return truncated H in specified basis.\"\"\"\n        phi_op = self.original_ops[\"phi\"]  \n        fourth_order_term =  - (1/24) * self.Ej * phi_op @ phi_op @ phi_op @ phi_op \n        sixth_order_term = (1/720) * self.Ej * phi_op @ phi_op @ phi_op @ phi_op @ phi_op @ phi_op\n        return self.get_H_linear() + fourth_order_term + sixth_order_term\n\n    def _get_H_in_original_basis(self):\n        \"\"\" This returns the Hamiltonian in the original specified basis. This can be overridden by subclasses.\"\"\"\n\n        if self.hamiltonian == HamiltonianTypes.linear:\n            return self.get_H_linear()\n        elif self.hamiltonian == HamiltonianTypes.full:\n            return self.get_H_full()\n        elif self.hamiltonian == HamiltonianTypes.truncated:\n            return self.get_H_truncated()\n\n    def potential(self, phi):\n        \"\"\"Return potential energy for a given phi.\"\"\"\n        if self.hamiltonian == HamiltonianTypes.linear:\n            return 0.5 * self.Ej * (2 * jnp.pi * phi) ** 2\n        elif self.hamiltonian == HamiltonianTypes.full:\n            return - self.Ej * jnp.cos(2 * jnp.pi * phi)\n        elif self.hamiltonian == HamiltonianTypes.truncated:\n            phi_scaled = 2 * jnp.pi * phi\n            second_order = 0.5 * self.Ej * phi_scaled ** 2\n            fourth_order =  - (1/24) * self.Ej * phi_scaled ** 4\n            sixth_order = (1/720) * self.Ej * phi_scaled ** 6\n            return second_order + fourth_order + sixth_order\n\n    def calculate_wavefunctions(self, phi_vals):\n        \"\"\"Calculate wavefunctions at phi_exts.\"\"\"\n\n        if self.basis == BasisTypes.fock:\n            return super().calculate_wavefunctions(phi_vals)\n        elif self.basis == BasisTypes.single_charge:\n            raise NotImplementedError(\"Wavefunctions for single charge basis not yet implemented.\")\n        elif self.basis == BasisTypes.charge:\n            phi_vals = jnp.array(phi_vals)\n\n            n_labels = jnp.diag(self.original_ops[\"n\"].data)\n\n            wavefunctions = []\n            for nj in range(self.N_pre_diag):\n                wavefunction = []\n                for phi in phi_vals:\n                    wavefunction.append(\n                        (1j ** nj / jnp.sqrt(2*jnp.pi)) * jnp.sum(\n                            self.eig_systems[\"vecs\"][:,nj] * jnp.exp(1j * phi * n_labels)\n                        )\n                    )\n                wavefunctions.append(jnp.array(wavefunction))\n            return jnp.array(wavefunctions)\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.Transmon.calculate_wavefunctions","title":"<code>calculate_wavefunctions(phi_vals)</code>","text":"<p>Calculate wavefunctions at phi_exts.</p> Source code in <code>qcsys/devices/transmon.py</code> <pre><code>def calculate_wavefunctions(self, phi_vals):\n    \"\"\"Calculate wavefunctions at phi_exts.\"\"\"\n\n    if self.basis == BasisTypes.fock:\n        return super().calculate_wavefunctions(phi_vals)\n    elif self.basis == BasisTypes.single_charge:\n        raise NotImplementedError(\"Wavefunctions for single charge basis not yet implemented.\")\n    elif self.basis == BasisTypes.charge:\n        phi_vals = jnp.array(phi_vals)\n\n        n_labels = jnp.diag(self.original_ops[\"n\"].data)\n\n        wavefunctions = []\n        for nj in range(self.N_pre_diag):\n            wavefunction = []\n            for phi in phi_vals:\n                wavefunction.append(\n                    (1j ** nj / jnp.sqrt(2*jnp.pi)) * jnp.sum(\n                        self.eig_systems[\"vecs\"][:,nj] * jnp.exp(1j * phi * n_labels)\n                    )\n                )\n            wavefunctions.append(jnp.array(wavefunction))\n        return jnp.array(wavefunctions)\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.Transmon.common_ops","title":"<code>common_ops()</code>","text":"<p>Written in the specified basis.</p> Source code in <code>qcsys/devices/transmon.py</code> <pre><code>def common_ops(self):\n    \"\"\" Written in the specified basis. \"\"\"\n\n    ops = {}\n\n    N = self.N_pre_diag\n\n    if self.basis == BasisTypes.fock:\n        ops[\"id\"] = jqt.identity(N)\n        ops[\"a\"] = jqt.destroy(N)\n        ops[\"a_dag\"] = jqt.create(N)\n        ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n        ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n    elif self.basis == BasisTypes.charge:\n        \"\"\"\n        Here H = 4 * Ec (n - ng)\u00b2 - Ej cos(\u03c6) in the Cooper pair charge basis. \n        \"\"\"\n        ops[\"id\"] = jqt.identity(N)\n        ops[\"cos(\u03c6)\"] = 0.5*(jqt.jnp2jqt(jnp.eye(N,k=1) + jnp.eye(N,k=-1)))\n        ops[\"sin(\u03c6)\"] = 0.5j*(jqt.jnp2jqt(jnp.eye(N,k=1) - jnp.eye(N,k=-1)))\n        n_max = (N - 1) // 2\n        ops[\"n\"] = jqt.jnp2jqt(jnp.diag(jnp.arange(-n_max, n_max + 1)))\n\n        n_minus_ng_array = jnp.arange(-n_max, n_max + 1) - self.params[\"ng\"] * jnp.ones(N)\n        ops[\"H_charge\"] = jqt.jnp2jqt(jnp.diag(4 * self.params[\"Ec\"] * n_minus_ng_array**2))\n\n    elif self.basis == BasisTypes.single_charge:\n        \"\"\"\n        Here H = Ec (n - 2ng)\u00b2 - Ej cos(\u03c6) in the single-electron charge basis. Using Eq. (5.36) of Kyle Serniak's\n        thesis, we have H = Ec \u2211\u2099(n - 2*ng) |n\u27e9\u27e8n| - Ej/2 * \u2211\u2099|n\u27e9\u27e8n+2| + h.c where n counts the number of electrons, \n        not Cooper pairs. Note, we use 2ng instead of ng to match the gate offset charge convention of the transmon \n        (as done in Kyle's thesis).\n        \"\"\"\n        n_max = (N - 1) // 2\n\n        ops[\"id\"] = jqt.identity(N)\n        ops[\"cos(\u03c6)\"] = 0.5*(jqt.jnp2jqt(jnp.eye(N,k=2) + jnp.eye(N,k=-2)))\n        ops[\"sin(\u03c6)\"] = 0.5j*(jqt.jnp2jqt(jnp.eye(N,k=2) - jnp.eye(N,k=-2)))\n        ops[\"cos(\u03c6/2)\"] = 0.5*(jqt.jnp2jqt(jnp.eye(N,k=1) + jnp.eye(N,k=-1)))\n        ops[\"sin(\u03c6/2)\"] = 0.5j*(jqt.jnp2jqt(jnp.eye(N,k=1) - jnp.eye(N,k=-1)))\n        ops[\"n\"] = jqt.jnp2jqt(jnp.diag(jnp.arange(-n_max, n_max + 1)))\n\n        n_minus_ng_array = jnp.arange(-n_max, n_max + 1) - 2 * self.params[\"ng\"] * jnp.ones(N)\n        ops[\"H_charge\"] = jqt.jnp2jqt(jnp.diag(self.params[\"Ec\"] * n_minus_ng_array**2))\n\n    return ops\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.Transmon.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in specified basis.</p> Source code in <code>qcsys/devices/transmon.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in specified basis.\"\"\"\n    return self.original_ops[\"H_charge\"] - self.Ej * self.original_ops[\"cos(\u03c6)\"]\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.Transmon.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>qcsys/devices/transmon.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_\u03c9()\n    return w * self.original_ops[\"a_dag\"] @ self.original_ops[\"a\"]\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.Transmon.get_H_truncated","title":"<code>get_H_truncated()</code>","text":"<p>Return truncated H in specified basis.</p> Source code in <code>qcsys/devices/transmon.py</code> <pre><code>def get_H_truncated(self):\n    \"\"\"Return truncated H in specified basis.\"\"\"\n    phi_op = self.original_ops[\"phi\"]  \n    fourth_order_term =  - (1/24) * self.Ej * phi_op @ phi_op @ phi_op @ phi_op \n    sixth_order_term = (1/720) * self.Ej * phi_op @ phi_op @ phi_op @ phi_op @ phi_op @ phi_op\n    return self.get_H_linear() + fourth_order_term + sixth_order_term\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.Transmon.get_linear_\u03c9","title":"<code>get_linear_\u03c9()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>qcsys/devices/transmon.py</code> <pre><code>def get_linear_\u03c9(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return jnp.sqrt(8 * self.params[\"Ec\"] * self.Ej)\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.Transmon.n_zpf","title":"<code>n_zpf()</code>","text":"<p>Return Charge ZPF.</p> Source code in <code>qcsys/devices/transmon.py</code> <pre><code>def n_zpf(self):\n    \"\"\"Return Charge ZPF.\"\"\"\n    return (self.Ej / (32 * self.params[\"Ec\"])) ** (0.25)\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.Transmon.param_validation","title":"<code>param_validation(N, N_pre_diag, params, hamiltonian, basis)</code>  <code>classmethod</code>","text":"<p>This can be overridden by subclasses.</p> Source code in <code>qcsys/devices/transmon.py</code> <pre><code>@classmethod\ndef param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n    \"\"\" This can be overridden by subclasses.\"\"\"\n    if hamiltonian == HamiltonianTypes.linear:\n        assert basis == BasisTypes.fock, \"Linear Hamiltonian only works with Fock basis.\"\n    elif hamiltonian == HamiltonianTypes.truncated:\n        assert basis == BasisTypes.fock, \"Truncated Hamiltonian only works with Fock basis.\"\n    elif hamiltonian == HamiltonianTypes.full:\n        assert basis in [BasisTypes.charge, BasisTypes.single_charge], \"Full Hamiltonian only works with Cooper pair charge or single-electron charge bases.\"\n\n    # Set the gate offset charge to zero if not provided\n    if \"ng\" not in params:\n        params[\"ng\"] = 0.0\n\n    assert (N_pre_diag - 1) % 2 == 0, \"N_pre_diag must be odd.\"\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.Transmon.phi_zpf","title":"<code>phi_zpf()</code>","text":"<p>Return Phase ZPF.</p> Source code in <code>qcsys/devices/transmon.py</code> <pre><code>def phi_zpf(self):\n    \"\"\"Return Phase ZPF.\"\"\"\n    return (2 * self.params[\"Ec\"] / self.Ej) ** (0.25)\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.Transmon.potential","title":"<code>potential(phi)</code>","text":"<p>Return potential energy for a given phi.</p> Source code in <code>qcsys/devices/transmon.py</code> <pre><code>def potential(self, phi):\n    \"\"\"Return potential energy for a given phi.\"\"\"\n    if self.hamiltonian == HamiltonianTypes.linear:\n        return 0.5 * self.Ej * (2 * jnp.pi * phi) ** 2\n    elif self.hamiltonian == HamiltonianTypes.full:\n        return - self.Ej * jnp.cos(2 * jnp.pi * phi)\n    elif self.hamiltonian == HamiltonianTypes.truncated:\n        phi_scaled = 2 * jnp.pi * phi\n        second_order = 0.5 * self.Ej * phi_scaled ** 2\n        fourth_order =  - (1/24) * self.Ej * phi_scaled ** 4\n        sixth_order = (1/720) * self.Ej * phi_scaled ** 6\n        return second_order + fourth_order + sixth_order\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.TunableTransmon","title":"<code>TunableTransmon</code>","text":"<p>               Bases: <code>Transmon</code></p> <p>Tunable Transmon Device.</p> Source code in <code>qcsys/devices/tunable_transmon.py</code> <pre><code>@struct.dataclass\nclass TunableTransmon(Transmon):\n    \"\"\"\n    Tunable Transmon Device.\n    \"\"\"\n\n    @property\n    def Ej(self):\n        Ejsum = (self.params[\"Ej1\"] + self.params[\"Ej2\"])\n        phi_ext = 2 * jnp.pi * self.params[\"phi_ext\"]\n        gamma = self.params[\"Ej2\"]/self.params[\"Ej1\"]\n        d = (gamma - 1)/(gamma + 1)\n        external_flux_factor = jnp.abs(jnp.sqrt(jnp.cos(phi_ext/2)**2 + d**2 * jnp.sin(phi_ext/2)**2))\n        return Ejsum * external_flux_factor\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.harm_osc_wavefunction","title":"<code>harm_osc_wavefunction(n, x, l_osc)</code>","text":"<p>Taken from scqubits... not jit-able</p> <p>For given quantum number n=0,1,2,... return the value of the harmonic oscillator wave function :math:<code>\\psi_n(x) = N H_n(x/l_{osc}) \\exp(-x^2/2l_\\text{ osc})</code>, N being the proper normalization factor.</p> <p>Directly uses <code>scipy.special.pbdv</code> (implementation of the parabolic cylinder function) to mitigate numerical stability issues with the more commonly used expression in terms of a Gaussian and a Hermite polynomial factor.</p>"},{"location":"reference/qcsys/index.html#qcsys.harm_osc_wavefunction--parameters","title":"Parameters","text":"<p>n:     index of wave function, n=0 is ground state x:     coordinate(s) where wave function is evaluated l_osc:     oscillator length, defined via &lt;0|x^2|0&gt; = l_osc^2/2</p>"},{"location":"reference/qcsys/index.html#qcsys.harm_osc_wavefunction--returns","title":"Returns","text":"<pre><code>value of harmonic oscillator wave function\n</code></pre> Source code in <code>qcsys/common/utils.py</code> <pre><code>def harm_osc_wavefunction(\n    n, x, l_osc\n):\n    r\"\"\"\n    Taken from scqubits... not jit-able\n\n    For given quantum number n=0,1,2,... return the value of the harmonic\n    oscillator wave function :math:`\\psi_n(x) = N H_n(x/l_{osc}) \\exp(-x^2/2l_\\text{\n    osc})`, N being the proper normalization factor.\n\n    Directly uses `scipy.special.pbdv` (implementation of the parabolic cylinder\n    function) to mitigate numerical stability issues with the more commonly used\n    expression in terms of a Gaussian and a Hermite polynomial factor.\n\n    Parameters\n    ----------\n    n:\n        index of wave function, n=0 is ground state\n    x:\n        coordinate(s) where wave function is evaluated\n    l_osc:\n        oscillator length, defined via &lt;0|x^2|0&gt; = l_osc^2/2\n\n    Returns\n    -------\n        value of harmonic oscillator wave function\n    \"\"\"\n    x = 2 * jnp.pi * x\n    result = pbdv(n, jnp.sqrt(2.0) * x / l_osc) [0]\n    result = result / jnp.sqrt(\n        l_osc * jnp.sqrt(jnp.pi) *  factorial_approx(n)\n    )\n    return result\n</code></pre>"},{"location":"reference/qcsys/index.html#qcsys.run_sweep","title":"<code>run_sweep(params, sweep_params, metrics_func, fixed_kwargs=None, data=None, is_parallel=False, save_file=None, data_save_mode='end', return_errors=False)</code>","text":"<p>Run a sweep over a single parameter, or multiple parameters.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict</code> <p>The base parameters to sweep over.</p> required <code>sweep_params</code> <code>dict</code> <p>The parameters to sweep over. key: The parameter name. value: The list of values to sweep over.</p> required <code>metrics_func</code> <code>function</code> <p>The function to evaluate the metrics.</p> required <code>fixed_params</code> <code>dict</code> <p>The fixed parameters to send into metrics_func. Defaults to None.</p> required <code>data</code> <code>dict</code> <p>The data to append to. Defaults to None.</p> <code>None</code> <code>is_parallel</code> <code>bool</code> <p>Whether to sweep through the sweep_params lists in parallel or through their cartesian product. Defaults to False.</p> <code>False</code> <code>save_file</code> <code>str</code> <p>The file to save the data to. Defaults to None, in which case data is saved to a temporary file, which will be deleted upon closing (e.g. during garbage collection).</p> <code>None</code> <code>data_save_mode</code> <code>str</code> <p>The mode to save the data. Defaults to None.  Options are:      \"no\" - don't save data      \"end\" - save data at the end of the sweep     \"during\" - save data during and at the end of the sweep</p> <code>'end'</code> <p>Returns:     dict: The data after the sweep.</p> Source code in <code>qcsys/analysis/sweeps.py</code> <pre><code>def run_sweep(params, sweep_params, metrics_func, fixed_kwargs=None, data=None, is_parallel=False, save_file=None, data_save_mode=\"end\", return_errors=False):\n    \"\"\" Run a sweep over a single parameter, or multiple parameters.\n\n    Args:\n        params (dict): The base parameters to sweep over.\n        sweep_params (dict): The parameters to sweep over.\n            key: The parameter name.\n            value: The list of values to sweep over.\n        metrics_func (function): The function to evaluate the metrics.\n        fixed_params (dict, optional): The fixed parameters to send into metrics_func. Defaults to None.\n        data (dict, optional): The data to append to. Defaults to None.\n        is_parallel (bool, optional): Whether to sweep through the sweep_params lists in parallel or through their cartesian product. Defaults to False.\n        save_file (str, optional): The file to save the data to. Defaults to None, in which case data is saved to a temporary file, which will be deleted upon closing (e.g. during garbage collection).\n        data_save_mode (str, optional): The mode to save the data. Defaults to None. \n            Options are: \n                \"no\" - don't save data \n                \"end\" - save data at the end of the sweep\n                \"during\" - save data during and at the end of the sweep\n    Returns:\n        dict: The data after the sweep.\n    \"\"\"\n    if data is None:\n        data = {}\n        run = -1\n    else:\n        run = max(data.keys())\n\n    assert data_save_mode in [\"no\", \"end\", \"during\"], \"Invalid data_save_mode.\"\n\n    if data_save_mode in [\"during\", \"end\"]:\n        if isinstance(save_file, str):\n            print(\"Saving data to: \", save_file)\n            dirname = os.path.dirname(save_file)\n            if not os.path.exists(dirname):\n                os.makedirs(dirname)\n        else:\n            save_file = save_file or NamedTemporaryFile()\n            print(\"Saving data to a temporary file: \", save_file.name)\n\n\n    fixed_kwargs = fixed_kwargs or {}\n\n    if is_parallel:\n        sweep_length = len(list(sweep_params.values())[0])\n        assert [len(vals) == sweep_length for vals in sweep_params.values()], \"Parallel sweep parameters must have the same length.\"\n\n        errors = []\n        try:\n            for j in tqdm(range(sweep_length)):\n                run += 1\n                data[run] = {}\n                data[run][\"params\"] = deepcopy(params)\n                sweep_point_info = {\n                    \"labels\": [],\n                    \"values\": [],\n                    \"indices\": [],\n                }\n                for key, vals in sweep_params.items():\n                    data[run][\"params\"][key] = vals[j]\n                    sweep_point_info[\"labels\"].append(key)\n                    sweep_point_info[\"values\"].append(vals[j])\n                    sweep_point_info[\"indices\"].append(j)\n                data[run][\"results\"] = metrics_func(data[run][\"params\"], **fixed_kwargs)\n                data[run][\"sweep_point_info\"] = sweep_point_info\n                if data_save_mode == \"during\":\n                    jnp.savez(save_file, data=data, sweep_params=sweep_params, params=params)\n        except Exception as e:\n            errors.append(str(e))\n            print(\"Error during run: \", errors[-1])\n\n        try:\n            if data_save_mode in [\"during\", \"end\"]:\n                jnp.savez(save_file, data=data, sweep_params=sweep_params, params=params, error=None)\n        except Exception as e:\n            errors.append(str(e))\n            print(\"Error during saving: \", errors[-1])\n\n        if return_errors:\n            return data, errors\n        else:\n            return data\n    else:\n        # Product Sweep\n        sweep_points = list(itertools.product(*list(sweep_params.values())))\n        sweep_points_indxs = list(itertools.product(*[list(range(len(vals))) for vals in list(sweep_params.values())]))\n        sweep_point_labels = list(sweep_params.keys())\n\n        errors = []\n\n        try:\n            with tqdm(total=len(sweep_points)) as pbar:\n                for j, sweep_point in enumerate(sweep_points):\n                    run += 1\n                    data[run] = {}\n                    data[run][\"params\"] = deepcopy(params)\n                    sweep_point_info = {\n                        \"labels\": [],\n                        \"values\": [],\n                        \"indices\": [],\n                    }\n                    for i, key in enumerate(sweep_point_labels):\n                        data[run][\"params\"][key] = sweep_point[i]\n                        sweep_point_info[\"labels\"].append(key)\n                        sweep_point_info[\"values\"].append(sweep_point[i])\n                        sweep_point_info[\"indices\"].append(sweep_points_indxs[j][i])\n                    data[run][\"results\"] = metrics_func(data[run][\"params\"], **fixed_kwargs)\n                    data[run][\"sweep_point_info\"] = sweep_point_info\n                    pbar.update(1)\n                    if data_save_mode == \"during\":\n                        jnp.savez(save_file, data=data, sweep_params=sweep_params, params=params)\n        except Exception as e:\n            errors.append(str(e))\n            print(\"Error during run: \", errors[-1])\n\n        try:\n            if data_save_mode in [\"during\", \"end\"]:\n                jnp.savez(save_file, data=data, sweep_params=sweep_params, params=params)\n        except Exception as e:\n            errors.append(str(e))\n            print(\"Error during saving: \", errors[-1])\n\n        if return_errors:\n            return data, errors\n        else:\n            return data\n</code></pre>"},{"location":"reference/qcsys/analysis/index.html","title":"analysis","text":"<p>Analysis Tools</p>"},{"location":"reference/qcsys/analysis/index.html#qcsys.analysis.run_sweep","title":"<code>run_sweep(params, sweep_params, metrics_func, fixed_kwargs=None, data=None, is_parallel=False, save_file=None, data_save_mode='end', return_errors=False)</code>","text":"<p>Run a sweep over a single parameter, or multiple parameters.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict</code> <p>The base parameters to sweep over.</p> required <code>sweep_params</code> <code>dict</code> <p>The parameters to sweep over. key: The parameter name. value: The list of values to sweep over.</p> required <code>metrics_func</code> <code>function</code> <p>The function to evaluate the metrics.</p> required <code>fixed_params</code> <code>dict</code> <p>The fixed parameters to send into metrics_func. Defaults to None.</p> required <code>data</code> <code>dict</code> <p>The data to append to. Defaults to None.</p> <code>None</code> <code>is_parallel</code> <code>bool</code> <p>Whether to sweep through the sweep_params lists in parallel or through their cartesian product. Defaults to False.</p> <code>False</code> <code>save_file</code> <code>str</code> <p>The file to save the data to. Defaults to None, in which case data is saved to a temporary file, which will be deleted upon closing (e.g. during garbage collection).</p> <code>None</code> <code>data_save_mode</code> <code>str</code> <p>The mode to save the data. Defaults to None.  Options are:      \"no\" - don't save data      \"end\" - save data at the end of the sweep     \"during\" - save data during and at the end of the sweep</p> <code>'end'</code> <p>Returns:     dict: The data after the sweep.</p> Source code in <code>qcsys/analysis/sweeps.py</code> <pre><code>def run_sweep(params, sweep_params, metrics_func, fixed_kwargs=None, data=None, is_parallel=False, save_file=None, data_save_mode=\"end\", return_errors=False):\n    \"\"\" Run a sweep over a single parameter, or multiple parameters.\n\n    Args:\n        params (dict): The base parameters to sweep over.\n        sweep_params (dict): The parameters to sweep over.\n            key: The parameter name.\n            value: The list of values to sweep over.\n        metrics_func (function): The function to evaluate the metrics.\n        fixed_params (dict, optional): The fixed parameters to send into metrics_func. Defaults to None.\n        data (dict, optional): The data to append to. Defaults to None.\n        is_parallel (bool, optional): Whether to sweep through the sweep_params lists in parallel or through their cartesian product. Defaults to False.\n        save_file (str, optional): The file to save the data to. Defaults to None, in which case data is saved to a temporary file, which will be deleted upon closing (e.g. during garbage collection).\n        data_save_mode (str, optional): The mode to save the data. Defaults to None. \n            Options are: \n                \"no\" - don't save data \n                \"end\" - save data at the end of the sweep\n                \"during\" - save data during and at the end of the sweep\n    Returns:\n        dict: The data after the sweep.\n    \"\"\"\n    if data is None:\n        data = {}\n        run = -1\n    else:\n        run = max(data.keys())\n\n    assert data_save_mode in [\"no\", \"end\", \"during\"], \"Invalid data_save_mode.\"\n\n    if data_save_mode in [\"during\", \"end\"]:\n        if isinstance(save_file, str):\n            print(\"Saving data to: \", save_file)\n            dirname = os.path.dirname(save_file)\n            if not os.path.exists(dirname):\n                os.makedirs(dirname)\n        else:\n            save_file = save_file or NamedTemporaryFile()\n            print(\"Saving data to a temporary file: \", save_file.name)\n\n\n    fixed_kwargs = fixed_kwargs or {}\n\n    if is_parallel:\n        sweep_length = len(list(sweep_params.values())[0])\n        assert [len(vals) == sweep_length for vals in sweep_params.values()], \"Parallel sweep parameters must have the same length.\"\n\n        errors = []\n        try:\n            for j in tqdm(range(sweep_length)):\n                run += 1\n                data[run] = {}\n                data[run][\"params\"] = deepcopy(params)\n                sweep_point_info = {\n                    \"labels\": [],\n                    \"values\": [],\n                    \"indices\": [],\n                }\n                for key, vals in sweep_params.items():\n                    data[run][\"params\"][key] = vals[j]\n                    sweep_point_info[\"labels\"].append(key)\n                    sweep_point_info[\"values\"].append(vals[j])\n                    sweep_point_info[\"indices\"].append(j)\n                data[run][\"results\"] = metrics_func(data[run][\"params\"], **fixed_kwargs)\n                data[run][\"sweep_point_info\"] = sweep_point_info\n                if data_save_mode == \"during\":\n                    jnp.savez(save_file, data=data, sweep_params=sweep_params, params=params)\n        except Exception as e:\n            errors.append(str(e))\n            print(\"Error during run: \", errors[-1])\n\n        try:\n            if data_save_mode in [\"during\", \"end\"]:\n                jnp.savez(save_file, data=data, sweep_params=sweep_params, params=params, error=None)\n        except Exception as e:\n            errors.append(str(e))\n            print(\"Error during saving: \", errors[-1])\n\n        if return_errors:\n            return data, errors\n        else:\n            return data\n    else:\n        # Product Sweep\n        sweep_points = list(itertools.product(*list(sweep_params.values())))\n        sweep_points_indxs = list(itertools.product(*[list(range(len(vals))) for vals in list(sweep_params.values())]))\n        sweep_point_labels = list(sweep_params.keys())\n\n        errors = []\n\n        try:\n            with tqdm(total=len(sweep_points)) as pbar:\n                for j, sweep_point in enumerate(sweep_points):\n                    run += 1\n                    data[run] = {}\n                    data[run][\"params\"] = deepcopy(params)\n                    sweep_point_info = {\n                        \"labels\": [],\n                        \"values\": [],\n                        \"indices\": [],\n                    }\n                    for i, key in enumerate(sweep_point_labels):\n                        data[run][\"params\"][key] = sweep_point[i]\n                        sweep_point_info[\"labels\"].append(key)\n                        sweep_point_info[\"values\"].append(sweep_point[i])\n                        sweep_point_info[\"indices\"].append(sweep_points_indxs[j][i])\n                    data[run][\"results\"] = metrics_func(data[run][\"params\"], **fixed_kwargs)\n                    data[run][\"sweep_point_info\"] = sweep_point_info\n                    pbar.update(1)\n                    if data_save_mode == \"during\":\n                        jnp.savez(save_file, data=data, sweep_params=sweep_params, params=params)\n        except Exception as e:\n            errors.append(str(e))\n            print(\"Error during run: \", errors[-1])\n\n        try:\n            if data_save_mode in [\"during\", \"end\"]:\n                jnp.savez(save_file, data=data, sweep_params=sweep_params, params=params)\n        except Exception as e:\n            errors.append(str(e))\n            print(\"Error during saving: \", errors[-1])\n\n        if return_errors:\n            return data, errors\n        else:\n            return data\n</code></pre>"},{"location":"reference/qcsys/analysis/sweeps.html","title":"sweeps","text":"<p>Sweeping tools.</p>"},{"location":"reference/qcsys/analysis/sweeps.html#qcsys.analysis.sweeps.run_sweep","title":"<code>run_sweep(params, sweep_params, metrics_func, fixed_kwargs=None, data=None, is_parallel=False, save_file=None, data_save_mode='end', return_errors=False)</code>","text":"<p>Run a sweep over a single parameter, or multiple parameters.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict</code> <p>The base parameters to sweep over.</p> required <code>sweep_params</code> <code>dict</code> <p>The parameters to sweep over. key: The parameter name. value: The list of values to sweep over.</p> required <code>metrics_func</code> <code>function</code> <p>The function to evaluate the metrics.</p> required <code>fixed_params</code> <code>dict</code> <p>The fixed parameters to send into metrics_func. Defaults to None.</p> required <code>data</code> <code>dict</code> <p>The data to append to. Defaults to None.</p> <code>None</code> <code>is_parallel</code> <code>bool</code> <p>Whether to sweep through the sweep_params lists in parallel or through their cartesian product. Defaults to False.</p> <code>False</code> <code>save_file</code> <code>str</code> <p>The file to save the data to. Defaults to None, in which case data is saved to a temporary file, which will be deleted upon closing (e.g. during garbage collection).</p> <code>None</code> <code>data_save_mode</code> <code>str</code> <p>The mode to save the data. Defaults to None.  Options are:      \"no\" - don't save data      \"end\" - save data at the end of the sweep     \"during\" - save data during and at the end of the sweep</p> <code>'end'</code> <p>Returns:     dict: The data after the sweep.</p> Source code in <code>qcsys/analysis/sweeps.py</code> <pre><code>def run_sweep(params, sweep_params, metrics_func, fixed_kwargs=None, data=None, is_parallel=False, save_file=None, data_save_mode=\"end\", return_errors=False):\n    \"\"\" Run a sweep over a single parameter, or multiple parameters.\n\n    Args:\n        params (dict): The base parameters to sweep over.\n        sweep_params (dict): The parameters to sweep over.\n            key: The parameter name.\n            value: The list of values to sweep over.\n        metrics_func (function): The function to evaluate the metrics.\n        fixed_params (dict, optional): The fixed parameters to send into metrics_func. Defaults to None.\n        data (dict, optional): The data to append to. Defaults to None.\n        is_parallel (bool, optional): Whether to sweep through the sweep_params lists in parallel or through their cartesian product. Defaults to False.\n        save_file (str, optional): The file to save the data to. Defaults to None, in which case data is saved to a temporary file, which will be deleted upon closing (e.g. during garbage collection).\n        data_save_mode (str, optional): The mode to save the data. Defaults to None. \n            Options are: \n                \"no\" - don't save data \n                \"end\" - save data at the end of the sweep\n                \"during\" - save data during and at the end of the sweep\n    Returns:\n        dict: The data after the sweep.\n    \"\"\"\n    if data is None:\n        data = {}\n        run = -1\n    else:\n        run = max(data.keys())\n\n    assert data_save_mode in [\"no\", \"end\", \"during\"], \"Invalid data_save_mode.\"\n\n    if data_save_mode in [\"during\", \"end\"]:\n        if isinstance(save_file, str):\n            print(\"Saving data to: \", save_file)\n            dirname = os.path.dirname(save_file)\n            if not os.path.exists(dirname):\n                os.makedirs(dirname)\n        else:\n            save_file = save_file or NamedTemporaryFile()\n            print(\"Saving data to a temporary file: \", save_file.name)\n\n\n    fixed_kwargs = fixed_kwargs or {}\n\n    if is_parallel:\n        sweep_length = len(list(sweep_params.values())[0])\n        assert [len(vals) == sweep_length for vals in sweep_params.values()], \"Parallel sweep parameters must have the same length.\"\n\n        errors = []\n        try:\n            for j in tqdm(range(sweep_length)):\n                run += 1\n                data[run] = {}\n                data[run][\"params\"] = deepcopy(params)\n                sweep_point_info = {\n                    \"labels\": [],\n                    \"values\": [],\n                    \"indices\": [],\n                }\n                for key, vals in sweep_params.items():\n                    data[run][\"params\"][key] = vals[j]\n                    sweep_point_info[\"labels\"].append(key)\n                    sweep_point_info[\"values\"].append(vals[j])\n                    sweep_point_info[\"indices\"].append(j)\n                data[run][\"results\"] = metrics_func(data[run][\"params\"], **fixed_kwargs)\n                data[run][\"sweep_point_info\"] = sweep_point_info\n                if data_save_mode == \"during\":\n                    jnp.savez(save_file, data=data, sweep_params=sweep_params, params=params)\n        except Exception as e:\n            errors.append(str(e))\n            print(\"Error during run: \", errors[-1])\n\n        try:\n            if data_save_mode in [\"during\", \"end\"]:\n                jnp.savez(save_file, data=data, sweep_params=sweep_params, params=params, error=None)\n        except Exception as e:\n            errors.append(str(e))\n            print(\"Error during saving: \", errors[-1])\n\n        if return_errors:\n            return data, errors\n        else:\n            return data\n    else:\n        # Product Sweep\n        sweep_points = list(itertools.product(*list(sweep_params.values())))\n        sweep_points_indxs = list(itertools.product(*[list(range(len(vals))) for vals in list(sweep_params.values())]))\n        sweep_point_labels = list(sweep_params.keys())\n\n        errors = []\n\n        try:\n            with tqdm(total=len(sweep_points)) as pbar:\n                for j, sweep_point in enumerate(sweep_points):\n                    run += 1\n                    data[run] = {}\n                    data[run][\"params\"] = deepcopy(params)\n                    sweep_point_info = {\n                        \"labels\": [],\n                        \"values\": [],\n                        \"indices\": [],\n                    }\n                    for i, key in enumerate(sweep_point_labels):\n                        data[run][\"params\"][key] = sweep_point[i]\n                        sweep_point_info[\"labels\"].append(key)\n                        sweep_point_info[\"values\"].append(sweep_point[i])\n                        sweep_point_info[\"indices\"].append(sweep_points_indxs[j][i])\n                    data[run][\"results\"] = metrics_func(data[run][\"params\"], **fixed_kwargs)\n                    data[run][\"sweep_point_info\"] = sweep_point_info\n                    pbar.update(1)\n                    if data_save_mode == \"during\":\n                        jnp.savez(save_file, data=data, sweep_params=sweep_params, params=params)\n        except Exception as e:\n            errors.append(str(e))\n            print(\"Error during run: \", errors[-1])\n\n        try:\n            if data_save_mode in [\"during\", \"end\"]:\n                jnp.savez(save_file, data=data, sweep_params=sweep_params, params=params)\n        except Exception as e:\n            errors.append(str(e))\n            print(\"Error during saving: \", errors[-1])\n\n        if return_errors:\n            return data, errors\n        else:\n            return data\n</code></pre>"},{"location":"reference/qcsys/common/index.html","title":"common","text":"<p>Common module.</p>"},{"location":"reference/qcsys/common/index.html#qcsys.common.harm_osc_wavefunction","title":"<code>harm_osc_wavefunction(n, x, l_osc)</code>","text":"<p>Taken from scqubits... not jit-able</p> <p>For given quantum number n=0,1,2,... return the value of the harmonic oscillator wave function :math:<code>\\psi_n(x) = N H_n(x/l_{osc}) \\exp(-x^2/2l_\\text{ osc})</code>, N being the proper normalization factor.</p> <p>Directly uses <code>scipy.special.pbdv</code> (implementation of the parabolic cylinder function) to mitigate numerical stability issues with the more commonly used expression in terms of a Gaussian and a Hermite polynomial factor.</p>"},{"location":"reference/qcsys/common/index.html#qcsys.common.harm_osc_wavefunction--parameters","title":"Parameters","text":"<p>n:     index of wave function, n=0 is ground state x:     coordinate(s) where wave function is evaluated l_osc:     oscillator length, defined via &lt;0|x^2|0&gt; = l_osc^2/2</p>"},{"location":"reference/qcsys/common/index.html#qcsys.common.harm_osc_wavefunction--returns","title":"Returns","text":"<pre><code>value of harmonic oscillator wave function\n</code></pre> Source code in <code>qcsys/common/utils.py</code> <pre><code>def harm_osc_wavefunction(\n    n, x, l_osc\n):\n    r\"\"\"\n    Taken from scqubits... not jit-able\n\n    For given quantum number n=0,1,2,... return the value of the harmonic\n    oscillator wave function :math:`\\psi_n(x) = N H_n(x/l_{osc}) \\exp(-x^2/2l_\\text{\n    osc})`, N being the proper normalization factor.\n\n    Directly uses `scipy.special.pbdv` (implementation of the parabolic cylinder\n    function) to mitigate numerical stability issues with the more commonly used\n    expression in terms of a Gaussian and a Hermite polynomial factor.\n\n    Parameters\n    ----------\n    n:\n        index of wave function, n=0 is ground state\n    x:\n        coordinate(s) where wave function is evaluated\n    l_osc:\n        oscillator length, defined via &lt;0|x^2|0&gt; = l_osc^2/2\n\n    Returns\n    -------\n        value of harmonic oscillator wave function\n    \"\"\"\n    x = 2 * jnp.pi * x\n    result = pbdv(n, jnp.sqrt(2.0) * x / l_osc) [0]\n    result = result / jnp.sqrt(\n        l_osc * jnp.sqrt(jnp.pi) *  factorial_approx(n)\n    )\n    return result\n</code></pre>"},{"location":"reference/qcsys/common/utils.html","title":"utils","text":"<p>Utility functions</p>"},{"location":"reference/qcsys/common/utils.html#qcsys.common.utils.harm_osc_wavefunction","title":"<code>harm_osc_wavefunction(n, x, l_osc)</code>","text":"<p>Taken from scqubits... not jit-able</p> <p>For given quantum number n=0,1,2,... return the value of the harmonic oscillator wave function :math:<code>\\psi_n(x) = N H_n(x/l_{osc}) \\exp(-x^2/2l_\\text{ osc})</code>, N being the proper normalization factor.</p> <p>Directly uses <code>scipy.special.pbdv</code> (implementation of the parabolic cylinder function) to mitigate numerical stability issues with the more commonly used expression in terms of a Gaussian and a Hermite polynomial factor.</p>"},{"location":"reference/qcsys/common/utils.html#qcsys.common.utils.harm_osc_wavefunction--parameters","title":"Parameters","text":"<p>n:     index of wave function, n=0 is ground state x:     coordinate(s) where wave function is evaluated l_osc:     oscillator length, defined via &lt;0|x^2|0&gt; = l_osc^2/2</p>"},{"location":"reference/qcsys/common/utils.html#qcsys.common.utils.harm_osc_wavefunction--returns","title":"Returns","text":"<pre><code>value of harmonic oscillator wave function\n</code></pre> Source code in <code>qcsys/common/utils.py</code> <pre><code>def harm_osc_wavefunction(\n    n, x, l_osc\n):\n    r\"\"\"\n    Taken from scqubits... not jit-able\n\n    For given quantum number n=0,1,2,... return the value of the harmonic\n    oscillator wave function :math:`\\psi_n(x) = N H_n(x/l_{osc}) \\exp(-x^2/2l_\\text{\n    osc})`, N being the proper normalization factor.\n\n    Directly uses `scipy.special.pbdv` (implementation of the parabolic cylinder\n    function) to mitigate numerical stability issues with the more commonly used\n    expression in terms of a Gaussian and a Hermite polynomial factor.\n\n    Parameters\n    ----------\n    n:\n        index of wave function, n=0 is ground state\n    x:\n        coordinate(s) where wave function is evaluated\n    l_osc:\n        oscillator length, defined via &lt;0|x^2|0&gt; = l_osc^2/2\n\n    Returns\n    -------\n        value of harmonic oscillator wave function\n    \"\"\"\n    x = 2 * jnp.pi * x\n    result = pbdv(n, jnp.sqrt(2.0) * x / l_osc) [0]\n    result = result / jnp.sqrt(\n        l_osc * jnp.sqrt(jnp.pi) *  factorial_approx(n)\n    )\n    return result\n</code></pre>"},{"location":"reference/qcsys/devices/index.html","title":"devices","text":"<p>Devices.</p>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.ATS","title":"<code>ATS</code>","text":"<p>               Bases: <code>FluxDevice</code></p> <p>ATS Device.</p> Source code in <code>qcsys/devices/ats.py</code> <pre><code>@struct.dataclass\nclass ATS(FluxDevice):        \n    \"\"\"\n    ATS Device.\n    \"\"\"\n\n    def common_ops(self):\n        \"\"\" Written in the linear basis. \"\"\"\n        ops = {}\n\n        N = self.N_pre_diag\n        ops[\"id\"] = jqt.identity(N)\n        ops[\"a\"] = jqt.destroy(N)\n        ops[\"a_dag\"] = jqt.create(N)\n        ops[\"phi\"] = self.phi_zpf()*(ops[\"a\"] + ops[\"a_dag\"])  \n        ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n        return ops\n\n    def phi_zpf(self):\n        \"\"\"Return Phase ZPF.\"\"\"\n        return (2*self.params[\"Ec\"]/self.params[\"El\"])**(.25)\n\n    def n_zpf(self):\n        \"\"\"Return Charge ZPF.\"\"\"\n        return (self.params[\"El\"]/(32*self.params[\"Ec\"]))**(.25)\n\n    def get_linear_\u03c9(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return jnp.sqrt(8*self.params[\"El\"]*self.params[\"Ec\"])\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_\u03c9()\n        return w*(self.linear_ops[\"a_dag\"]@self.linear_ops[\"a\"] + 0.5 * self.linear_ops[\"id\"])\n\n    @staticmethod\n    def get_H_nonlinear_static(phi_op, Ej, dEj, Ej2, phi_sum, phi_delta):\n        cos_phi_op = jqt.cosm(phi_op)\n        sin_phi_op = jqt.sinm(phi_op)\n\n        cos_2phi_op = cos_phi_op @ cos_phi_op - sin_phi_op @ sin_phi_op\n        sin_2phi_op = 2 * cos_phi_op @ sin_phi_op\n\n        H_nl_Ej = - 2 * Ej * (\n            cos_phi_op * jnp.cos(2 * jnp.pi * phi_delta) \n            - sin_phi_op * jnp.sin(2 * jnp.pi * phi_delta)\n        ) * jnp.cos(2 * jnp.pi * phi_sum)\n        H_nl_dEj = 2 * dEj * (\n            sin_phi_op * jnp.cos(2 * jnp.pi * phi_delta)\n            + cos_phi_op * jnp.sin(2 * jnp.pi * phi_delta)\n        ) * jnp.sin(2 * jnp.pi * phi_sum) \n        H_nl_Ej2 = 2 * Ej2 * (\n            cos_2phi_op * jnp.cos(2 * 2 * jnp.pi * phi_delta)\n            - sin_2phi_op * jnp.sin(2 * 2 * jnp.pi * phi_delta)\n        ) * jnp.cos(2 * 2 * jnp.pi * phi_sum)\n\n        H_nl = H_nl_Ej + H_nl_dEj + H_nl_Ej2\n\n\n        # id_op = jqt.identity_like(phi_op)\n        # phi_delta_ext_op = self.params[\"phi_delta_ext\"] * id_op\n        # H_nl_old = - 2 * Ej * jqt.cosm(phi_op + 2 * jnp.pi * phi_delta_ext_op) * jnp.cos(2 * jnp.pi * self.params[\"phi_sum_ext\"])\n        # H_nl_old += 2 * dEj * jqt.sinm(phi_op + 2 * jnp.pi * phi_delta_ext_op) * jnp.sin(2 * jnp.pi * self.params[\"phi_sum_ext\"]) \n        # H_nl_old += 2 * Ej2 * jqt.cosm(2*phi_op + 2 * 2 * jnp.pi * phi_delta_ext_op) * jnp.cos(2 * 2 * jnp.pi * self.params[\"phi_sum_ext\"])\n\n        return H_nl\n\n    def get_H_nonlinear(self, phi_op):\n        \"\"\"Return nonlinear terms in H.\"\"\"\n\n        Ej = self.params[\"Ej\"]\n        dEj = self.params[\"dEj\"]\n        Ej2 = self.params[\"Ej2\"]\n\n        phi_sum = self.params[\"phi_sum_ext\"]\n        phi_delta = self.params[\"phi_delta_ext\"]\n\n        return ATS.get_H_nonlinear_static(\n            phi_op, \n            Ej, \n            dEj, \n            Ej2, \n            phi_sum, \n            phi_delta\n        )\n\n\n    def get_H_full(self):\n        \"\"\"Return full H in linear basis.\"\"\"\n        id_op = self.linear_ops[\"id\"]\n        phi_b = self.linear_ops[\"phi\"]\n        H_nl = self.get_H_nonlinear(phi_b)\n        H = self.get_H_linear() + H_nl\n        return H\n\n    def potential(self, phi):\n        \"\"\"Return potential energy for a given phi.\"\"\"\n\n        phi_delta_ext = self.params[\"phi_delta_ext\"]\n        phi_sum_ext = self.params[\"phi_sum_ext\"]\n\n        V = 0.5 * self.params[\"El\"] * (2 * jnp.pi * phi) ** 2\n        V += - 2 * self.params[\"Ej\"] * jnp.cos(2 * jnp.pi * (phi + phi_delta_ext)) * jnp.cos(2 * jnp.pi * phi_sum_ext)\n        V += 2 * self.params[\"dEj\"] * jnp.sin(2 * jnp.pi * (phi + phi_delta_ext)) * jnp.sin(2 * jnp.pi * phi_sum_ext)\n        V += 2 * self.params[\"Ej2\"] * jnp.cos(2 * 2 * jnp.pi * (phi + phi_delta_ext)) * jnp.cos(2 * 2 * jnp.pi * phi_sum_ext)\n\n        return V\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.ATS.common_ops","title":"<code>common_ops()</code>","text":"<p>Written in the linear basis.</p> Source code in <code>qcsys/devices/ats.py</code> <pre><code>def common_ops(self):\n    \"\"\" Written in the linear basis. \"\"\"\n    ops = {}\n\n    N = self.N_pre_diag\n    ops[\"id\"] = jqt.identity(N)\n    ops[\"a\"] = jqt.destroy(N)\n    ops[\"a_dag\"] = jqt.create(N)\n    ops[\"phi\"] = self.phi_zpf()*(ops[\"a\"] + ops[\"a_dag\"])  \n    ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n    return ops\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.ATS.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in linear basis.</p> Source code in <code>qcsys/devices/ats.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in linear basis.\"\"\"\n    id_op = self.linear_ops[\"id\"]\n    phi_b = self.linear_ops[\"phi\"]\n    H_nl = self.get_H_nonlinear(phi_b)\n    H = self.get_H_linear() + H_nl\n    return H\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.ATS.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>qcsys/devices/ats.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_\u03c9()\n    return w*(self.linear_ops[\"a_dag\"]@self.linear_ops[\"a\"] + 0.5 * self.linear_ops[\"id\"])\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.ATS.get_H_nonlinear","title":"<code>get_H_nonlinear(phi_op)</code>","text":"<p>Return nonlinear terms in H.</p> Source code in <code>qcsys/devices/ats.py</code> <pre><code>def get_H_nonlinear(self, phi_op):\n    \"\"\"Return nonlinear terms in H.\"\"\"\n\n    Ej = self.params[\"Ej\"]\n    dEj = self.params[\"dEj\"]\n    Ej2 = self.params[\"Ej2\"]\n\n    phi_sum = self.params[\"phi_sum_ext\"]\n    phi_delta = self.params[\"phi_delta_ext\"]\n\n    return ATS.get_H_nonlinear_static(\n        phi_op, \n        Ej, \n        dEj, \n        Ej2, \n        phi_sum, \n        phi_delta\n    )\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.ATS.get_linear_\u03c9","title":"<code>get_linear_\u03c9()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>qcsys/devices/ats.py</code> <pre><code>def get_linear_\u03c9(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return jnp.sqrt(8*self.params[\"El\"]*self.params[\"Ec\"])\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.ATS.n_zpf","title":"<code>n_zpf()</code>","text":"<p>Return Charge ZPF.</p> Source code in <code>qcsys/devices/ats.py</code> <pre><code>def n_zpf(self):\n    \"\"\"Return Charge ZPF.\"\"\"\n    return (self.params[\"El\"]/(32*self.params[\"Ec\"]))**(.25)\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.ATS.phi_zpf","title":"<code>phi_zpf()</code>","text":"<p>Return Phase ZPF.</p> Source code in <code>qcsys/devices/ats.py</code> <pre><code>def phi_zpf(self):\n    \"\"\"Return Phase ZPF.\"\"\"\n    return (2*self.params[\"Ec\"]/self.params[\"El\"])**(.25)\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.ATS.potential","title":"<code>potential(phi)</code>","text":"<p>Return potential energy for a given phi.</p> Source code in <code>qcsys/devices/ats.py</code> <pre><code>def potential(self, phi):\n    \"\"\"Return potential energy for a given phi.\"\"\"\n\n    phi_delta_ext = self.params[\"phi_delta_ext\"]\n    phi_sum_ext = self.params[\"phi_sum_ext\"]\n\n    V = 0.5 * self.params[\"El\"] * (2 * jnp.pi * phi) ** 2\n    V += - 2 * self.params[\"Ej\"] * jnp.cos(2 * jnp.pi * (phi + phi_delta_ext)) * jnp.cos(2 * jnp.pi * phi_sum_ext)\n    V += 2 * self.params[\"dEj\"] * jnp.sin(2 * jnp.pi * (phi + phi_delta_ext)) * jnp.sin(2 * jnp.pi * phi_sum_ext)\n    V += 2 * self.params[\"Ej2\"] * jnp.cos(2 * 2 * jnp.pi * (phi + phi_delta_ext)) * jnp.cos(2 * 2 * jnp.pi * phi_sum_ext)\n\n    return V\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.Device","title":"<code>Device</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>qcsys/devices/base.py</code> <pre><code>@struct.dataclass\nclass Device(ABC):\n    N: int = struct.field(pytree_node=False)\n    N_pre_diag: int = struct.field(pytree_node=False)\n    params: Dict[str, Any]\n    _label: int = struct.field(pytree_node=False)\n    _basis: BasisTypes = struct.field(pytree_node=False)\n    _hamiltonian: HamiltonianTypes = struct.field(pytree_node=False)\n\n    @classmethod\n    def param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n        \"\"\" This can be overridden by subclasses.\"\"\"\n        pass\n\n    @classmethod\n    def create(cls, N, params, label=0, N_pre_diag=None,use_linear=False, hamiltonian: HamiltonianTypes = None, basis: BasisTypes = None):\n        \"\"\"Create a device.\n\n        Args:\n            N (int): dimension of Hilbert space.\n            params (dict): parameters of the device.\n            label (int, optional): label for the device. Defaults to 0. This is useful when you have multiple of the same device type in the same system.\n            N_pre_diag (int, optional): dimension of Hilbert space before diagonalization. Defaults to None, in which case it is set to N. This must be greater than or rqual to N.\n            use_linear (bool): whether to use the linearized device. Defaults to False. This will override the hamiltonian keyword argument. This is a bit redundant with hamiltonian, but it is kept for backwards compatibility.\n            hamiltonian (HamiltonianTypes, optional): type of Hamiltonian. Defaults to None, in which case the full hamiltonian is used.\n            basis (BasisTypes, optional): type of basis. Defaults to None, in which case the fock basis is used.\n        \"\"\"\n\n        if N_pre_diag is None:\n            N_pre_diag = N\n\n        assert N_pre_diag &gt;= N, \"N_pre_diag must be greater than or equal to N.\"\n\n        _basis = basis if basis is not None else BasisTypes.fock\n        _hamiltonian = hamiltonian if hamiltonian is not None else HamiltonianTypes.full\n        if use_linear:\n            _hamiltonian = HamiltonianTypes.linear\n\n        cls.param_validation(N, N_pre_diag, params, _hamiltonian, _basis)\n\n        return cls(N, N_pre_diag, params, label, _basis, _hamiltonian)\n\n    @property\n    def basis(self):\n        return self._basis\n\n    @property\n    def hamiltonian(self):\n        return self._hamiltonian\n\n    @property\n    def label(self):\n        return self.__class__.__name__ + str(self._label)\n\n    @property\n    def linear_ops(self):\n        return self.common_ops()\n\n    @property\n    def original_ops(self):\n        return self.common_ops()\n\n    @property\n    def ops(self):\n        return self.full_ops()\n\n    @abstractmethod\n    def common_ops(self) -&gt; Dict[str, jqt.Qarray]:\n        \"\"\"Set up common ops in the specified basis.\"\"\"\n\n    @abstractmethod\n    def get_linear_\u03c9(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n\n    @abstractmethod\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n\n    @abstractmethod\n    def get_H_full(self):\n        \"\"\"Return full H.\"\"\"\n\n    def get_H(self):\n        \"\"\"\n        Return diagonalized H. Explicitly keep only diagonal elements of matrix.\n        \"\"\"\n        return self.get_op_in_H_eigenbasis(self._get_H_in_original_basis()).keep_only_diag_elements()\n\n    def _get_H_in_original_basis(self):\n        \"\"\" This returns the Hamiltonian in the original specified basis. This can be overridden by subclasses.\"\"\"\n\n        if self.hamiltonian == HamiltonianTypes.linear:\n            return self.get_H_linear()\n        elif self.hamiltonian == HamiltonianTypes.full:\n            return self.get_H_full()\n\n    def _calculate_eig_systems(self):\n        evs, evecs = jnp.linalg.eigh(self._get_H_in_original_basis().data)  # Hermitian\n        idxs_sorted = jnp.argsort(evs)\n        return evs[idxs_sorted], evecs[:, idxs_sorted]\n\n    @property\n    def eig_systems(self):\n        eig_systems = {}\n        eig_systems[\"vals\"], eig_systems[\"vecs\"] = self._calculate_eig_systems()\n\n        eig_systems[\"vecs\"] = eig_systems[\"vecs\"]\n        eig_systems[\"vals\"] = eig_systems[\"vals\"]\n        return eig_systems\n\n    def get_op_in_H_eigenbasis(self, op: jqt.Qarray):\n        evecs = self.eig_systems[\"vecs\"][:, : self.N]\n        dims = [[self.N], [self.N]]\n        return get_op_in_new_basis(op, evecs, dims)\n\n    def get_op_data_in_H_eigenbasis(self, op: Array):\n        evecs = self.eig_systems[\"vecs\"][:, : self.N]\n        return get_op_data_in_new_basis(op, evecs)\n\n    def get_vec_in_H_eigenbasis(self, vec: jqt.Qarray):\n        evecs = self.eig_systems[\"vecs\"][:, : self.N]\n        if vec.qtype == jqt.Qtypes.ket:\n            dims = [[self.N],[1]]\n        else:\n            dims = [[1], [self.N]]\n        return get_vec_in_new_basis(vec, evecs, dims)\n\n    def get_vec_data_in_H_eigenbasis(self, vec: Array):\n        evecs = self.eig_systems[\"vecs\"][:, : self.N]\n        return get_vec_data_in_new_basis(vec, evecs)\n\n    def full_ops(self):\n        # TODO: use JAX vmap here\n\n        linear_ops = self.linear_ops\n        ops = {}\n        for name, op in linear_ops.items():\n            ops[name] = self.get_op_in_H_eigenbasis(op)\n\n        return ops\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.Device.common_ops","title":"<code>common_ops()</code>  <code>abstractmethod</code>","text":"<p>Set up common ops in the specified basis.</p> Source code in <code>qcsys/devices/base.py</code> <pre><code>@abstractmethod\ndef common_ops(self) -&gt; Dict[str, jqt.Qarray]:\n    \"\"\"Set up common ops in the specified basis.\"\"\"\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.Device.create","title":"<code>create(N, params, label=0, N_pre_diag=None, use_linear=False, hamiltonian=None, basis=None)</code>  <code>classmethod</code>","text":"<p>Create a device.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>dimension of Hilbert space.</p> required <code>params</code> <code>dict</code> <p>parameters of the device.</p> required <code>label</code> <code>int</code> <p>label for the device. Defaults to 0. This is useful when you have multiple of the same device type in the same system.</p> <code>0</code> <code>N_pre_diag</code> <code>int</code> <p>dimension of Hilbert space before diagonalization. Defaults to None, in which case it is set to N. This must be greater than or rqual to N.</p> <code>None</code> <code>use_linear</code> <code>bool</code> <p>whether to use the linearized device. Defaults to False. This will override the hamiltonian keyword argument. This is a bit redundant with hamiltonian, but it is kept for backwards compatibility.</p> <code>False</code> <code>hamiltonian</code> <code>HamiltonianTypes</code> <p>type of Hamiltonian. Defaults to None, in which case the full hamiltonian is used.</p> <code>None</code> <code>basis</code> <code>BasisTypes</code> <p>type of basis. Defaults to None, in which case the fock basis is used.</p> <code>None</code> Source code in <code>qcsys/devices/base.py</code> <pre><code>@classmethod\ndef create(cls, N, params, label=0, N_pre_diag=None,use_linear=False, hamiltonian: HamiltonianTypes = None, basis: BasisTypes = None):\n    \"\"\"Create a device.\n\n    Args:\n        N (int): dimension of Hilbert space.\n        params (dict): parameters of the device.\n        label (int, optional): label for the device. Defaults to 0. This is useful when you have multiple of the same device type in the same system.\n        N_pre_diag (int, optional): dimension of Hilbert space before diagonalization. Defaults to None, in which case it is set to N. This must be greater than or rqual to N.\n        use_linear (bool): whether to use the linearized device. Defaults to False. This will override the hamiltonian keyword argument. This is a bit redundant with hamiltonian, but it is kept for backwards compatibility.\n        hamiltonian (HamiltonianTypes, optional): type of Hamiltonian. Defaults to None, in which case the full hamiltonian is used.\n        basis (BasisTypes, optional): type of basis. Defaults to None, in which case the fock basis is used.\n    \"\"\"\n\n    if N_pre_diag is None:\n        N_pre_diag = N\n\n    assert N_pre_diag &gt;= N, \"N_pre_diag must be greater than or equal to N.\"\n\n    _basis = basis if basis is not None else BasisTypes.fock\n    _hamiltonian = hamiltonian if hamiltonian is not None else HamiltonianTypes.full\n    if use_linear:\n        _hamiltonian = HamiltonianTypes.linear\n\n    cls.param_validation(N, N_pre_diag, params, _hamiltonian, _basis)\n\n    return cls(N, N_pre_diag, params, label, _basis, _hamiltonian)\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.Device.get_H","title":"<code>get_H()</code>","text":"<p>Return diagonalized H. Explicitly keep only diagonal elements of matrix.</p> Source code in <code>qcsys/devices/base.py</code> <pre><code>def get_H(self):\n    \"\"\"\n    Return diagonalized H. Explicitly keep only diagonal elements of matrix.\n    \"\"\"\n    return self.get_op_in_H_eigenbasis(self._get_H_in_original_basis()).keep_only_diag_elements()\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.Device.get_H_full","title":"<code>get_H_full()</code>  <code>abstractmethod</code>","text":"<p>Return full H.</p> Source code in <code>qcsys/devices/base.py</code> <pre><code>@abstractmethod\ndef get_H_full(self):\n    \"\"\"Return full H.\"\"\"\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.Device.get_H_linear","title":"<code>get_H_linear()</code>  <code>abstractmethod</code>","text":"<p>Return linear terms in H.</p> Source code in <code>qcsys/devices/base.py</code> <pre><code>@abstractmethod\ndef get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.Device.get_linear_\u03c9","title":"<code>get_linear_\u03c9()</code>  <code>abstractmethod</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>qcsys/devices/base.py</code> <pre><code>@abstractmethod\ndef get_linear_\u03c9(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.Device.param_validation","title":"<code>param_validation(N, N_pre_diag, params, hamiltonian, basis)</code>  <code>classmethod</code>","text":"<p>This can be overridden by subclasses.</p> Source code in <code>qcsys/devices/base.py</code> <pre><code>@classmethod\ndef param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n    \"\"\" This can be overridden by subclasses.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.Drive","title":"<code>Drive</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>qcsys/devices/drive.py</code> <pre><code>@struct.dataclass\nclass Drive(ABC):\n    N: int = struct.field(pytree_node=False)\n    \u03c9d: float\n    _label: int = struct.field(pytree_node=False)\n\n    @classmethod\n    def create(cls, M_max, \u03c9d, label=0):\n        cls.M_max = M_max\n        N = 2 * M_max + 1\n        return cls(N, \u03c9d, label)\n\n    @property\n    def label(self):\n        return self.__class__.__name__ + str(self._label)\n\n    @property\n    def ops(self):\n        return self.common_ops()\n\n    def common_ops(self) -&gt; Dict[str, jqt.Qarray]:\n        ops = {}\n\n        M_max = self.M_max\n\n        # Construct M = \u2211\u2098 m|m&gt;&lt;m| operator in drive charge basis\n        ops[\"M\"] = jqt.jnp2jqt(jnp.diag(jnp.arange(-M_max, M_max + 1)))\n\n        # Construct Id = \u2211\u2098|m&gt;&lt;m| in the drive charge basis\n        ops[\"id\"] = jqt.jnp2jqt(jnp.identity(2 * M_max + 1))\n\n        # Construct M\u208a \u2261 exp(i\u03b8) and M\u208b \u2261 exp(-i\u03b8) operators for drive\n        ops[\"M-\"] = jqt.jnp2jqt(jnp.eye(2 * M_max + 1, k=1))\n        ops[\"M+\"] = jqt.jnp2jqt(jnp.eye(2 * M_max + 1, k=-1))\n\n        # Construct cos(\u03b8) \u2261 1/2 * [M\u208a + M\u208b] = 1/2 * \u2211\u2098|m+1&gt;&lt;m| + h.c\n        ops[\"cos(\u03b8)\"] = 0.5 * (ops[\"M+\"] + ops[\"M-\"])\n\n        # Construct sin(\u03b8) \u2261 -i/2 * [M\u208a - M\u208b] = -i/2 * \u2211\u2098|m+1&gt;&lt;m| + h.c\n        ops[\"sin(\u03b8)\"] = -0.5j * (ops[\"M+\"] - ops[\"M-\"])\n\n        # Construct more general drive operators cos(k\u03b8) and sin(k\u03b8)\n        for k in range(2, M_max + 1):\n            ops[f\"M_+{k}\"] = jqt.jnp2jqt(jnp.eye(2 * M_max + 1, k=-k))\n            ops[f\"M_-{k}\"] = jqt.jnp2jqt(jnp.eye(2 * M_max + 1, k=k))\n            ops[f\"cos({k}\u03b8)\"] = 0.5 * (ops[f\"M_+{k}\"] + ops[f\"M_-{k}\"])\n            ops[f\"sin({k}\u03b8)\"] = -0.5j * (ops[f\"M_+{k}\"] - ops[f\"M_-{k}\"])\n\n        return ops\n\n    #############################################################\n\n    def get_H(self):\n        \"\"\"\n        Bare \"drive\" Hamiltonian (\u03c9d * M) in the extended Hilbert space.\n        \"\"\"\n        return self.\u03c9d * self.ops[\"M\"]\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.Drive.get_H","title":"<code>get_H()</code>","text":"<p>Bare \"drive\" Hamiltonian (\u03c9d * M) in the extended Hilbert space.</p> Source code in <code>qcsys/devices/drive.py</code> <pre><code>def get_H(self):\n    \"\"\"\n    Bare \"drive\" Hamiltonian (\u03c9d * M) in the extended Hilbert space.\n    \"\"\"\n    return self.\u03c9d * self.ops[\"M\"]\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.FluxDevice","title":"<code>FluxDevice</code>","text":"<p>               Bases: <code>Device</code></p> Source code in <code>qcsys/devices/base.py</code> <pre><code>@struct.dataclass\nclass FluxDevice(Device):\n    @abstractmethod\n    def phi_zpf(self):\n        \"\"\"Return Phase ZPF.\"\"\"\n\n    def _calculate_wavefunctions_fock(self, phi_vals):\n        \"\"\"Calculate wavefunctions at phi_exts.\"\"\"\n        phi_osc = self.phi_zpf() * jnp.sqrt(2) # length of oscillator\n        phi_vals = jnp.array(phi_vals)\n\n        # calculate basis functions\n        basis_functions = []\n        for n in range(self.N_pre_diag):\n            basis_functions.append(\n                harm_osc_wavefunction(n, phi_vals, jnp.real(phi_osc))\n            )\n        basis_functions = jnp.array(basis_functions)\n\n        # transform to better diagonal basis\n        basis_functions_in_H_eigenbasis = self.get_vec_data_in_H_eigenbasis(basis_functions)\n\n        # the below is equivalent to evecs_in_H_eigenbasis @ basis_functions_in_H_eigenbasis\n        # since evecs in H_eigenbasis is diagonal, i.e. the identity matrix\n        wavefunctions = basis_functions_in_H_eigenbasis \n        return wavefunctions\n\n    def _calculate_wavefunctions_charge(self, phi_vals):\n        phi_vals = jnp.array(phi_vals)\n\n        # calculate basis functions\n        basis_functions = []\n        n_max = (self.N_pre_diag - 1) // 2\n        for n in jnp.arange(-n_max, n_max + 1):\n            basis_functions.append(\n                1/(jnp.sqrt(2*jnp.pi)) * jnp.exp(1j * n * (2*jnp.pi*phi_vals))\n            )\n        basis_functions = jnp.array(basis_functions)\n\n        # transform to better diagonal basis\n        basis_functions_in_H_eigenbasis = self.get_vec_data_in_H_eigenbasis(basis_functions)\n\n        # the below is equivalent to evecs_in_H_eigenbasis @ basis_functions_in_H_eigenbasis\n        # since evecs in H_eigenbasis is diagonal, i.e. the identity matrix\n        phase_correction_factors =  (1j**(jnp.arange(0,self.N_pre_diag))).reshape(self.N_pre_diag,1) # TODO: review why these are needed...\n        wavefunctions = basis_functions_in_H_eigenbasis * phase_correction_factors\n        return wavefunctions\n\n    @abstractmethod\n    def potential(self, phi):\n        \"\"\"Return potential energy as a function of phi.\"\"\"\n\n    def plot_wavefunctions(self, phi_vals, max_n=None, which=None, ax=None, mode=\"abs\"):\n\n        if self.basis == BasisTypes.fock:\n            _calculate_wavefunctions = self._calculate_wavefunctions_fock\n        elif self.basis == BasisTypes.charge:\n            _calculate_wavefunctions = self._calculate_wavefunctions_charge\n        else:\n            raise NotImplementedError(f\"The {self.basis} is not yet supported for plotting wavefunctions.\")\n\n        \"\"\"Plot wavefunctions at phi_exts.\"\"\"\n        wavefunctions = _calculate_wavefunctions(phi_vals)\n        energy_levels = self.eig_systems[\"vals\"][:self.N]\n\n        potential = self.potential(phi_vals)\n\n        if ax is None:\n            fig, ax = plt.subplots(1,1, figsize = (3.5, 2.5), dpi = 1000)\n        else:\n            fig = ax.get_figure()\n\n        min_val = None\n        max_val = None\n\n        assert max_n is None or which is None, \"Can't specify both max_n and which\"\n\n        max_n = self.N if max_n is None else max_n\n        levels = range(max_n) if which is None else which\n\n        for n in levels:\n            if mode == \"abs\":\n                wf_vals = jnp.abs(wavefunctions[n, :])**2\n            elif mode == \"real\":\n                wf_vals = wavefunctions[n, :].real\n            elif mode == \"imag\":\n                wf_vals = wavefunctions[n, :].imag\n\n            wf_vals += energy_levels[n]\n            curr_min_val = min(wf_vals)\n            curr_max_val = max(wf_vals)\n\n            if min_val is None or curr_min_val &lt; min_val:\n                min_val = curr_min_val\n\n            if max_val is None or curr_max_val &gt; max_val:\n                max_val = curr_max_val\n\n            ax.plot(phi_vals, wf_vals, label=f\"$|${n}$\\\\rangle$\", linestyle = '-', linewidth = 1)\n            ax.fill_between(phi_vals, energy_levels[n], wf_vals, alpha=0.5)\n\n        ax.plot(phi_vals, potential, label=\"potential\", color=\"black\", linestyle = '-', linewidth = 1)\n\n        ax.set_ylim([min_val-1, max_val+1])\n\n        ax.set_xlabel(r\"$\\Phi/\\Phi_0$\")\n        ax.set_ylabel(r\"Energy [GHz]\")\n\n        if mode == \"abs\":\n            title_str = r\"$|\\psi_n(\\Phi)|^2$\"\n        elif mode == \"real\":\n            title_str = r\"Re($\\psi_n(\\Phi)$)\"\n        elif mode == \"imag\":\n            title_str = r\"Im($\\psi_n(\\Phi)$)\"\n\n        ax.set_title(f\"{title_str}\")\n\n        plt.legend(fontsize=6)\n        fig.tight_layout()\n\n        return ax\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.FluxDevice.phi_zpf","title":"<code>phi_zpf()</code>  <code>abstractmethod</code>","text":"<p>Return Phase ZPF.</p> Source code in <code>qcsys/devices/base.py</code> <pre><code>@abstractmethod\ndef phi_zpf(self):\n    \"\"\"Return Phase ZPF.\"\"\"\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.FluxDevice.potential","title":"<code>potential(phi)</code>  <code>abstractmethod</code>","text":"<p>Return potential energy as a function of phi.</p> Source code in <code>qcsys/devices/base.py</code> <pre><code>@abstractmethod\ndef potential(self, phi):\n    \"\"\"Return potential energy as a function of phi.\"\"\"\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.Fluxonium","title":"<code>Fluxonium</code>","text":"<p>               Bases: <code>FluxDevice</code></p> <p>Fluxonium Device.</p> Source code in <code>qcsys/devices/fluxonium.py</code> <pre><code>@struct.dataclass\nclass Fluxonium(FluxDevice):\n    \"\"\"\n    Fluxonium Device.\n    \"\"\"\n\n    def common_ops(self):\n        \"\"\" Written in the linear basis. \"\"\"\n        ops = {}\n\n        N = self.N_pre_diag\n        ops[\"id\"] = jqt.identity(N)\n        ops[\"a\"] = jqt.destroy(N)\n        ops[\"a_dag\"] = jqt.create(N)\n        ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n        ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n        ops[\"cos(\u03c6/2)\"] = jqt.cosm(ops[\"phi\"] / 2)\n        ops[\"sin(\u03c6/2)\"] = jqt.sinm(ops[\"phi\"] / 2)\n\n        return ops\n\n    def n_zpf(self):\n        n_zpf = (self.params[\"El\"] / (32.0 * self.params[\"Ec\"])) ** (0.25)\n        return n_zpf\n\n    def phi_zpf(self):\n        \"\"\"Return Phase ZPF.\"\"\"\n        return (2 * self.params[\"Ec\"] / self.params[\"El\"]) ** (0.25)\n\n    def get_linear_\u03c9(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return jnp.sqrt(8 * self.params[\"Ec\"] * self.params[\"El\"])\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_\u03c9()\n        return w * (\n            self.linear_ops[\"a_dag\"] @ self.linear_ops[\"a\"]\n            + 0.5 * self.linear_ops[\"id\"]\n        )\n\n    def get_H_full(self):\n        \"\"\"Return full H in linear basis.\"\"\"\n\n        phi_op = self.linear_ops[\"phi\"]\n        return self.get_H_linear() + self.get_H_nonlinear(phi_op)\n\n    def get_H_nonlinear(self, phi_op):\n        op_cos_phi = jqt.cosm(phi_op)\n        op_sin_phi = jqt.sinm(phi_op)\n\n        phi_ext = self.params[\"phi_ext\"]\n        Hcos = op_cos_phi * jnp.cos(2.0 * jnp.pi * phi_ext) + op_sin_phi * jnp.sin(\n            2.0 * jnp.pi * phi_ext\n        )\n        H_nl = - self.params[\"Ej\"] * Hcos\n        return H_nl\n\n    def potential(self, phi):\n        \"\"\"Return potential energy for a given phi.\"\"\"\n        phi_ext = self.params[\"phi_ext\"]\n        V_linear = 0.5 * self.params[\"El\"] * (2 * jnp.pi * phi) ** 2\n\n        if self.hamiltonian == HamiltonianTypes.linear:\n            return V_linear\n\n        V_nonlinear = -self.params[\"Ej\"] * jnp.cos(2.0 * jnp.pi * (phi - phi_ext))\n        if self.hamiltonian == HamiltonianTypes.full:\n            return V_linear + V_nonlinear\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.Fluxonium.common_ops","title":"<code>common_ops()</code>","text":"<p>Written in the linear basis.</p> Source code in <code>qcsys/devices/fluxonium.py</code> <pre><code>def common_ops(self):\n    \"\"\" Written in the linear basis. \"\"\"\n    ops = {}\n\n    N = self.N_pre_diag\n    ops[\"id\"] = jqt.identity(N)\n    ops[\"a\"] = jqt.destroy(N)\n    ops[\"a_dag\"] = jqt.create(N)\n    ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n    ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n    ops[\"cos(\u03c6/2)\"] = jqt.cosm(ops[\"phi\"] / 2)\n    ops[\"sin(\u03c6/2)\"] = jqt.sinm(ops[\"phi\"] / 2)\n\n    return ops\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.Fluxonium.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in linear basis.</p> Source code in <code>qcsys/devices/fluxonium.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in linear basis.\"\"\"\n\n    phi_op = self.linear_ops[\"phi\"]\n    return self.get_H_linear() + self.get_H_nonlinear(phi_op)\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.Fluxonium.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>qcsys/devices/fluxonium.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_\u03c9()\n    return w * (\n        self.linear_ops[\"a_dag\"] @ self.linear_ops[\"a\"]\n        + 0.5 * self.linear_ops[\"id\"]\n    )\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.Fluxonium.get_linear_\u03c9","title":"<code>get_linear_\u03c9()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>qcsys/devices/fluxonium.py</code> <pre><code>def get_linear_\u03c9(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return jnp.sqrt(8 * self.params[\"Ec\"] * self.params[\"El\"])\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.Fluxonium.phi_zpf","title":"<code>phi_zpf()</code>","text":"<p>Return Phase ZPF.</p> Source code in <code>qcsys/devices/fluxonium.py</code> <pre><code>def phi_zpf(self):\n    \"\"\"Return Phase ZPF.\"\"\"\n    return (2 * self.params[\"Ec\"] / self.params[\"El\"]) ** (0.25)\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.Fluxonium.potential","title":"<code>potential(phi)</code>","text":"<p>Return potential energy for a given phi.</p> Source code in <code>qcsys/devices/fluxonium.py</code> <pre><code>def potential(self, phi):\n    \"\"\"Return potential energy for a given phi.\"\"\"\n    phi_ext = self.params[\"phi_ext\"]\n    V_linear = 0.5 * self.params[\"El\"] * (2 * jnp.pi * phi) ** 2\n\n    if self.hamiltonian == HamiltonianTypes.linear:\n        return V_linear\n\n    V_nonlinear = -self.params[\"Ej\"] * jnp.cos(2.0 * jnp.pi * (phi - phi_ext))\n    if self.hamiltonian == HamiltonianTypes.full:\n        return V_linear + V_nonlinear\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.IdealQubit","title":"<code>IdealQubit</code>","text":"<p>               Bases: <code>Device</code></p> <p>Ideal qubit Device.</p> Source code in <code>qcsys/devices/ideal_qubit.py</code> <pre><code>@struct.dataclass\nclass IdealQubit(Device):\n    \"\"\"\n    Ideal qubit Device.\n    \"\"\"\n\n    @classmethod\n    def param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n        \"\"\" This can be overridden by subclasses.\"\"\"\n        assert basis == BasisTypes.fock, \"IdealQubit is a two-level system defined in the Fock basis.\" \n        assert hamiltonian == HamiltonianTypes.full, \"IdealQubit requires a full Hamiltonian.\"\n        assert N == N_pre_diag == 2, \"IdealQubit is a two-level system.\"\n        assert \"\u03c9\" in params, \"IdealQubit requires a frequency parameter '\u03c9'.\"\n\n    def common_ops(self):\n        \"\"\"Written in the linear basis.\"\"\"\n        ops = {}\n\n        assert self.N_pre_diag == 2\n        assert self.N == 2\n\n        N = self.N_pre_diag\n        ops[\"id\"] = jqt.identity(N)\n        ops[\"sigmaz\"] = jqt.sigmaz()\n        ops[\"sigmax\"] = jqt.sigmax()\n        ops[\"sigmay\"] = jqt.sigmay()\n        ops[\"sigmam\"] = jqt.sigmam()\n        ops[\"sigmap\"] = jqt.sigmap()\n\n        return ops\n\n    def get_linear_\u03c9(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return self.params[\"\u03c9\"]\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_\u03c9()\n        return (w / 2) * self.linear_ops[\"sigma_z\"]\n\n    def get_H_full(self):\n        \"\"\"Return full H in linear basis.\"\"\"\n        return self.get_H_linear()\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.IdealQubit.common_ops","title":"<code>common_ops()</code>","text":"<p>Written in the linear basis.</p> Source code in <code>qcsys/devices/ideal_qubit.py</code> <pre><code>def common_ops(self):\n    \"\"\"Written in the linear basis.\"\"\"\n    ops = {}\n\n    assert self.N_pre_diag == 2\n    assert self.N == 2\n\n    N = self.N_pre_diag\n    ops[\"id\"] = jqt.identity(N)\n    ops[\"sigmaz\"] = jqt.sigmaz()\n    ops[\"sigmax\"] = jqt.sigmax()\n    ops[\"sigmay\"] = jqt.sigmay()\n    ops[\"sigmam\"] = jqt.sigmam()\n    ops[\"sigmap\"] = jqt.sigmap()\n\n    return ops\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.IdealQubit.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in linear basis.</p> Source code in <code>qcsys/devices/ideal_qubit.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in linear basis.\"\"\"\n    return self.get_H_linear()\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.IdealQubit.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>qcsys/devices/ideal_qubit.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_\u03c9()\n    return (w / 2) * self.linear_ops[\"sigma_z\"]\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.IdealQubit.get_linear_\u03c9","title":"<code>get_linear_\u03c9()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>qcsys/devices/ideal_qubit.py</code> <pre><code>def get_linear_\u03c9(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return self.params[\"\u03c9\"]\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.IdealQubit.param_validation","title":"<code>param_validation(N, N_pre_diag, params, hamiltonian, basis)</code>  <code>classmethod</code>","text":"<p>This can be overridden by subclasses.</p> Source code in <code>qcsys/devices/ideal_qubit.py</code> <pre><code>@classmethod\ndef param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n    \"\"\" This can be overridden by subclasses.\"\"\"\n    assert basis == BasisTypes.fock, \"IdealQubit is a two-level system defined in the Fock basis.\" \n    assert hamiltonian == HamiltonianTypes.full, \"IdealQubit requires a full Hamiltonian.\"\n    assert N == N_pre_diag == 2, \"IdealQubit is a two-level system.\"\n    assert \"\u03c9\" in params, \"IdealQubit requires a frequency parameter '\u03c9'.\"\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.KNO","title":"<code>KNO</code>","text":"<p>               Bases: <code>Device</code></p> <p>Kerr Nonlinear Oscillator Device.</p> Source code in <code>qcsys/devices/kno.py</code> <pre><code>@struct.dataclass\nclass KNO(Device):\n    \"\"\"\n    Kerr Nonlinear Oscillator Device.\n    \"\"\"\n\n    @classmethod\n    def param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n        \"\"\" This can be overridden by subclasses.\"\"\"\n        assert basis == BasisTypes.fock, \"Kerr Nonlinear Oscillator must be defined in the Fock basis.\" \n        assert hamiltonian == HamiltonianTypes.full, \"Kerr Nonlinear Oscillator uses a full Hamiltonian.\"\n        assert \"\u03c9\" in params and \"\u03b1\" in params, \"Kerr Nonlinear Oscillator requires frequency '\u03c9' and anharmonicity '\u03b1' as parameters.\"\n\n    def common_ops(self):\n        ops = {}\n\n        N = self.N\n        ops[\"id\"] = jqt.identity(N)\n        ops[\"a\"] = jqt.destroy(N)\n        ops[\"a_dag\"] = jqt.create(N)\n        ops[\"phi\"] = (ops[\"a\"] + ops[\"a_dag\"]) / jnp.sqrt(2)\n        ops[\"n\"] = 1j * (ops[\"a_dag\"] - ops[\"a\"]) / jnp.sqrt(2)\n        return ops\n\n    def get_linear_\u03c9(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return self.params[\"\u03c9\"]\n\n    def get_anharm(self):\n        \"\"\"Get anharmonicity.\"\"\"\n        return self.params[\"\u03b1\"]\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_\u03c9()\n        return w * self.linear_ops[\"a_dag\"] @ self.linear_ops[\"a\"]\n\n    def get_H_full(self):\n        \"\"\"Return full H in linear basis.\"\"\"\n        \u03b1 = self.get_anharm()\n\n        return self.get_H_linear() + (\u03b1 / 2) * (\n            self.linear_ops[\"a_dag\"]\n            @ self.linear_ops[\"a_dag\"]\n            @ self.linear_ops[\"a\"]\n            @ self.linear_ops[\"a\"]\n        )\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.KNO.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in linear basis.</p> Source code in <code>qcsys/devices/kno.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in linear basis.\"\"\"\n    \u03b1 = self.get_anharm()\n\n    return self.get_H_linear() + (\u03b1 / 2) * (\n        self.linear_ops[\"a_dag\"]\n        @ self.linear_ops[\"a_dag\"]\n        @ self.linear_ops[\"a\"]\n        @ self.linear_ops[\"a\"]\n    )\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.KNO.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>qcsys/devices/kno.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_\u03c9()\n    return w * self.linear_ops[\"a_dag\"] @ self.linear_ops[\"a\"]\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.KNO.get_anharm","title":"<code>get_anharm()</code>","text":"<p>Get anharmonicity.</p> Source code in <code>qcsys/devices/kno.py</code> <pre><code>def get_anharm(self):\n    \"\"\"Get anharmonicity.\"\"\"\n    return self.params[\"\u03b1\"]\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.KNO.get_linear_\u03c9","title":"<code>get_linear_\u03c9()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>qcsys/devices/kno.py</code> <pre><code>def get_linear_\u03c9(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return self.params[\"\u03c9\"]\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.KNO.param_validation","title":"<code>param_validation(N, N_pre_diag, params, hamiltonian, basis)</code>  <code>classmethod</code>","text":"<p>This can be overridden by subclasses.</p> Source code in <code>qcsys/devices/kno.py</code> <pre><code>@classmethod\ndef param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n    \"\"\" This can be overridden by subclasses.\"\"\"\n    assert basis == BasisTypes.fock, \"Kerr Nonlinear Oscillator must be defined in the Fock basis.\" \n    assert hamiltonian == HamiltonianTypes.full, \"Kerr Nonlinear Oscillator uses a full Hamiltonian.\"\n    assert \"\u03c9\" in params and \"\u03b1\" in params, \"Kerr Nonlinear Oscillator requires frequency '\u03c9' and anharmonicity '\u03b1' as parameters.\"\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.Resonator","title":"<code>Resonator</code>","text":"<p>               Bases: <code>FluxDevice</code></p> <p>Resonator Device.</p> Source code in <code>qcsys/devices/resonator.py</code> <pre><code>@struct.dataclass\nclass Resonator(FluxDevice):        \n    \"\"\"\n    Resonator Device.\n    \"\"\"\n\n    def common_ops(self):\n        \"\"\" Written in the linear basis. \"\"\"\n        ops = {}\n\n        N = self.N_pre_diag\n        ops[\"id\"] = jqt.identity(N)\n        ops[\"a\"] = jqt.destroy(N)\n        ops[\"a_dag\"] = jqt.create(N)\n        ops[\"phi\"] = self.phi_zpf()*(ops[\"a\"] + ops[\"a_dag\"])  \n        ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n        return ops\n\n    def phi_zpf(self):\n        \"\"\"Return Phase ZPF.\"\"\"\n        return (2*self.params[\"Ec\"]/self.params[\"El\"])**(.25)\n\n    def n_zpf(self):\n        n_zpf = (self.params[\"El\"] / (32.0 * self.params[\"Ec\"])) ** (0.25)\n        return n_zpf\n\n    def get_linear_\u03c9(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return jnp.sqrt(8*self.params[\"El\"]*self.params[\"Ec\"])\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_\u03c9()\n        return w*(self.linear_ops[\"a_dag\"]@self.linear_ops[\"a\"] + 1/2)\n\n    def get_H_full(self):\n        \"\"\"Return full H in linear basis.\"\"\"\n        return self.get_H_linear()\n\n    def potential(self, phi):\n        \"\"\"Return potential energy for a given phi.\"\"\"\n        return 0.5 * self.params[\"El\"] * (2 * jnp.pi * phi) ** 2\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.Resonator.common_ops","title":"<code>common_ops()</code>","text":"<p>Written in the linear basis.</p> Source code in <code>qcsys/devices/resonator.py</code> <pre><code>def common_ops(self):\n    \"\"\" Written in the linear basis. \"\"\"\n    ops = {}\n\n    N = self.N_pre_diag\n    ops[\"id\"] = jqt.identity(N)\n    ops[\"a\"] = jqt.destroy(N)\n    ops[\"a_dag\"] = jqt.create(N)\n    ops[\"phi\"] = self.phi_zpf()*(ops[\"a\"] + ops[\"a_dag\"])  \n    ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n    return ops\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.Resonator.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in linear basis.</p> Source code in <code>qcsys/devices/resonator.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in linear basis.\"\"\"\n    return self.get_H_linear()\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.Resonator.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>qcsys/devices/resonator.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_\u03c9()\n    return w*(self.linear_ops[\"a_dag\"]@self.linear_ops[\"a\"] + 1/2)\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.Resonator.get_linear_\u03c9","title":"<code>get_linear_\u03c9()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>qcsys/devices/resonator.py</code> <pre><code>def get_linear_\u03c9(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return jnp.sqrt(8*self.params[\"El\"]*self.params[\"Ec\"])\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.Resonator.phi_zpf","title":"<code>phi_zpf()</code>","text":"<p>Return Phase ZPF.</p> Source code in <code>qcsys/devices/resonator.py</code> <pre><code>def phi_zpf(self):\n    \"\"\"Return Phase ZPF.\"\"\"\n    return (2*self.params[\"Ec\"]/self.params[\"El\"])**(.25)\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.Resonator.potential","title":"<code>potential(phi)</code>","text":"<p>Return potential energy for a given phi.</p> Source code in <code>qcsys/devices/resonator.py</code> <pre><code>def potential(self, phi):\n    \"\"\"Return potential energy for a given phi.\"\"\"\n    return 0.5 * self.params[\"El\"] * (2 * jnp.pi * phi) ** 2\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.Transmon","title":"<code>Transmon</code>","text":"<p>               Bases: <code>FluxDevice</code></p> <p>Transmon Device.</p> Source code in <code>qcsys/devices/transmon.py</code> <pre><code>@struct.dataclass\nclass Transmon(FluxDevice):\n    \"\"\"\n    Transmon Device.\n    \"\"\"\n\n    @classmethod\n    def param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n        \"\"\" This can be overridden by subclasses.\"\"\"\n        if hamiltonian == HamiltonianTypes.linear:\n            assert basis == BasisTypes.fock, \"Linear Hamiltonian only works with Fock basis.\"\n        elif hamiltonian == HamiltonianTypes.truncated:\n            assert basis == BasisTypes.fock, \"Truncated Hamiltonian only works with Fock basis.\"\n        elif hamiltonian == HamiltonianTypes.full:\n            assert basis in [BasisTypes.charge, BasisTypes.single_charge], \"Full Hamiltonian only works with Cooper pair charge or single-electron charge bases.\"\n\n        # Set the gate offset charge to zero if not provided\n        if \"ng\" not in params:\n            params[\"ng\"] = 0.0\n\n        assert (N_pre_diag - 1) % 2 == 0, \"N_pre_diag must be odd.\"\n\n    def common_ops(self):\n        \"\"\" Written in the specified basis. \"\"\"\n\n        ops = {}\n\n        N = self.N_pre_diag\n\n        if self.basis == BasisTypes.fock:\n            ops[\"id\"] = jqt.identity(N)\n            ops[\"a\"] = jqt.destroy(N)\n            ops[\"a_dag\"] = jqt.create(N)\n            ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n            ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n        elif self.basis == BasisTypes.charge:\n            \"\"\"\n            Here H = 4 * Ec (n - ng)\u00b2 - Ej cos(\u03c6) in the Cooper pair charge basis. \n            \"\"\"\n            ops[\"id\"] = jqt.identity(N)\n            ops[\"cos(\u03c6)\"] = 0.5*(jqt.jnp2jqt(jnp.eye(N,k=1) + jnp.eye(N,k=-1)))\n            ops[\"sin(\u03c6)\"] = 0.5j*(jqt.jnp2jqt(jnp.eye(N,k=1) - jnp.eye(N,k=-1)))\n            n_max = (N - 1) // 2\n            ops[\"n\"] = jqt.jnp2jqt(jnp.diag(jnp.arange(-n_max, n_max + 1)))\n\n            n_minus_ng_array = jnp.arange(-n_max, n_max + 1) - self.params[\"ng\"] * jnp.ones(N)\n            ops[\"H_charge\"] = jqt.jnp2jqt(jnp.diag(4 * self.params[\"Ec\"] * n_minus_ng_array**2))\n\n        elif self.basis == BasisTypes.single_charge:\n            \"\"\"\n            Here H = Ec (n - 2ng)\u00b2 - Ej cos(\u03c6) in the single-electron charge basis. Using Eq. (5.36) of Kyle Serniak's\n            thesis, we have H = Ec \u2211\u2099(n - 2*ng) |n\u27e9\u27e8n| - Ej/2 * \u2211\u2099|n\u27e9\u27e8n+2| + h.c where n counts the number of electrons, \n            not Cooper pairs. Note, we use 2ng instead of ng to match the gate offset charge convention of the transmon \n            (as done in Kyle's thesis).\n            \"\"\"\n            n_max = (N - 1) // 2\n\n            ops[\"id\"] = jqt.identity(N)\n            ops[\"cos(\u03c6)\"] = 0.5*(jqt.jnp2jqt(jnp.eye(N,k=2) + jnp.eye(N,k=-2)))\n            ops[\"sin(\u03c6)\"] = 0.5j*(jqt.jnp2jqt(jnp.eye(N,k=2) - jnp.eye(N,k=-2)))\n            ops[\"cos(\u03c6/2)\"] = 0.5*(jqt.jnp2jqt(jnp.eye(N,k=1) + jnp.eye(N,k=-1)))\n            ops[\"sin(\u03c6/2)\"] = 0.5j*(jqt.jnp2jqt(jnp.eye(N,k=1) - jnp.eye(N,k=-1)))\n            ops[\"n\"] = jqt.jnp2jqt(jnp.diag(jnp.arange(-n_max, n_max + 1)))\n\n            n_minus_ng_array = jnp.arange(-n_max, n_max + 1) - 2 * self.params[\"ng\"] * jnp.ones(N)\n            ops[\"H_charge\"] = jqt.jnp2jqt(jnp.diag(self.params[\"Ec\"] * n_minus_ng_array**2))\n\n        return ops\n\n    @property\n    def Ej(self):\n        return self.params[\"Ej\"]\n\n    def phi_zpf(self):\n        \"\"\"Return Phase ZPF.\"\"\"\n        return (2 * self.params[\"Ec\"] / self.Ej) ** (0.25)\n\n    def n_zpf(self):\n        \"\"\"Return Charge ZPF.\"\"\"\n        return (self.Ej / (32 * self.params[\"Ec\"])) ** (0.25)\n\n    def get_linear_\u03c9(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return jnp.sqrt(8 * self.params[\"Ec\"] * self.Ej)\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_\u03c9()\n        return w * self.original_ops[\"a_dag\"] @ self.original_ops[\"a\"]\n\n    def get_H_full(self):\n        \"\"\"Return full H in specified basis.\"\"\"\n        return self.original_ops[\"H_charge\"] - self.Ej * self.original_ops[\"cos(\u03c6)\"]\n\n    def get_H_truncated(self):\n        \"\"\"Return truncated H in specified basis.\"\"\"\n        phi_op = self.original_ops[\"phi\"]  \n        fourth_order_term =  - (1/24) * self.Ej * phi_op @ phi_op @ phi_op @ phi_op \n        sixth_order_term = (1/720) * self.Ej * phi_op @ phi_op @ phi_op @ phi_op @ phi_op @ phi_op\n        return self.get_H_linear() + fourth_order_term + sixth_order_term\n\n    def _get_H_in_original_basis(self):\n        \"\"\" This returns the Hamiltonian in the original specified basis. This can be overridden by subclasses.\"\"\"\n\n        if self.hamiltonian == HamiltonianTypes.linear:\n            return self.get_H_linear()\n        elif self.hamiltonian == HamiltonianTypes.full:\n            return self.get_H_full()\n        elif self.hamiltonian == HamiltonianTypes.truncated:\n            return self.get_H_truncated()\n\n    def potential(self, phi):\n        \"\"\"Return potential energy for a given phi.\"\"\"\n        if self.hamiltonian == HamiltonianTypes.linear:\n            return 0.5 * self.Ej * (2 * jnp.pi * phi) ** 2\n        elif self.hamiltonian == HamiltonianTypes.full:\n            return - self.Ej * jnp.cos(2 * jnp.pi * phi)\n        elif self.hamiltonian == HamiltonianTypes.truncated:\n            phi_scaled = 2 * jnp.pi * phi\n            second_order = 0.5 * self.Ej * phi_scaled ** 2\n            fourth_order =  - (1/24) * self.Ej * phi_scaled ** 4\n            sixth_order = (1/720) * self.Ej * phi_scaled ** 6\n            return second_order + fourth_order + sixth_order\n\n    def calculate_wavefunctions(self, phi_vals):\n        \"\"\"Calculate wavefunctions at phi_exts.\"\"\"\n\n        if self.basis == BasisTypes.fock:\n            return super().calculate_wavefunctions(phi_vals)\n        elif self.basis == BasisTypes.single_charge:\n            raise NotImplementedError(\"Wavefunctions for single charge basis not yet implemented.\")\n        elif self.basis == BasisTypes.charge:\n            phi_vals = jnp.array(phi_vals)\n\n            n_labels = jnp.diag(self.original_ops[\"n\"].data)\n\n            wavefunctions = []\n            for nj in range(self.N_pre_diag):\n                wavefunction = []\n                for phi in phi_vals:\n                    wavefunction.append(\n                        (1j ** nj / jnp.sqrt(2*jnp.pi)) * jnp.sum(\n                            self.eig_systems[\"vecs\"][:,nj] * jnp.exp(1j * phi * n_labels)\n                        )\n                    )\n                wavefunctions.append(jnp.array(wavefunction))\n            return jnp.array(wavefunctions)\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.Transmon.calculate_wavefunctions","title":"<code>calculate_wavefunctions(phi_vals)</code>","text":"<p>Calculate wavefunctions at phi_exts.</p> Source code in <code>qcsys/devices/transmon.py</code> <pre><code>def calculate_wavefunctions(self, phi_vals):\n    \"\"\"Calculate wavefunctions at phi_exts.\"\"\"\n\n    if self.basis == BasisTypes.fock:\n        return super().calculate_wavefunctions(phi_vals)\n    elif self.basis == BasisTypes.single_charge:\n        raise NotImplementedError(\"Wavefunctions for single charge basis not yet implemented.\")\n    elif self.basis == BasisTypes.charge:\n        phi_vals = jnp.array(phi_vals)\n\n        n_labels = jnp.diag(self.original_ops[\"n\"].data)\n\n        wavefunctions = []\n        for nj in range(self.N_pre_diag):\n            wavefunction = []\n            for phi in phi_vals:\n                wavefunction.append(\n                    (1j ** nj / jnp.sqrt(2*jnp.pi)) * jnp.sum(\n                        self.eig_systems[\"vecs\"][:,nj] * jnp.exp(1j * phi * n_labels)\n                    )\n                )\n            wavefunctions.append(jnp.array(wavefunction))\n        return jnp.array(wavefunctions)\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.Transmon.common_ops","title":"<code>common_ops()</code>","text":"<p>Written in the specified basis.</p> Source code in <code>qcsys/devices/transmon.py</code> <pre><code>def common_ops(self):\n    \"\"\" Written in the specified basis. \"\"\"\n\n    ops = {}\n\n    N = self.N_pre_diag\n\n    if self.basis == BasisTypes.fock:\n        ops[\"id\"] = jqt.identity(N)\n        ops[\"a\"] = jqt.destroy(N)\n        ops[\"a_dag\"] = jqt.create(N)\n        ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n        ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n    elif self.basis == BasisTypes.charge:\n        \"\"\"\n        Here H = 4 * Ec (n - ng)\u00b2 - Ej cos(\u03c6) in the Cooper pair charge basis. \n        \"\"\"\n        ops[\"id\"] = jqt.identity(N)\n        ops[\"cos(\u03c6)\"] = 0.5*(jqt.jnp2jqt(jnp.eye(N,k=1) + jnp.eye(N,k=-1)))\n        ops[\"sin(\u03c6)\"] = 0.5j*(jqt.jnp2jqt(jnp.eye(N,k=1) - jnp.eye(N,k=-1)))\n        n_max = (N - 1) // 2\n        ops[\"n\"] = jqt.jnp2jqt(jnp.diag(jnp.arange(-n_max, n_max + 1)))\n\n        n_minus_ng_array = jnp.arange(-n_max, n_max + 1) - self.params[\"ng\"] * jnp.ones(N)\n        ops[\"H_charge\"] = jqt.jnp2jqt(jnp.diag(4 * self.params[\"Ec\"] * n_minus_ng_array**2))\n\n    elif self.basis == BasisTypes.single_charge:\n        \"\"\"\n        Here H = Ec (n - 2ng)\u00b2 - Ej cos(\u03c6) in the single-electron charge basis. Using Eq. (5.36) of Kyle Serniak's\n        thesis, we have H = Ec \u2211\u2099(n - 2*ng) |n\u27e9\u27e8n| - Ej/2 * \u2211\u2099|n\u27e9\u27e8n+2| + h.c where n counts the number of electrons, \n        not Cooper pairs. Note, we use 2ng instead of ng to match the gate offset charge convention of the transmon \n        (as done in Kyle's thesis).\n        \"\"\"\n        n_max = (N - 1) // 2\n\n        ops[\"id\"] = jqt.identity(N)\n        ops[\"cos(\u03c6)\"] = 0.5*(jqt.jnp2jqt(jnp.eye(N,k=2) + jnp.eye(N,k=-2)))\n        ops[\"sin(\u03c6)\"] = 0.5j*(jqt.jnp2jqt(jnp.eye(N,k=2) - jnp.eye(N,k=-2)))\n        ops[\"cos(\u03c6/2)\"] = 0.5*(jqt.jnp2jqt(jnp.eye(N,k=1) + jnp.eye(N,k=-1)))\n        ops[\"sin(\u03c6/2)\"] = 0.5j*(jqt.jnp2jqt(jnp.eye(N,k=1) - jnp.eye(N,k=-1)))\n        ops[\"n\"] = jqt.jnp2jqt(jnp.diag(jnp.arange(-n_max, n_max + 1)))\n\n        n_minus_ng_array = jnp.arange(-n_max, n_max + 1) - 2 * self.params[\"ng\"] * jnp.ones(N)\n        ops[\"H_charge\"] = jqt.jnp2jqt(jnp.diag(self.params[\"Ec\"] * n_minus_ng_array**2))\n\n    return ops\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.Transmon.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in specified basis.</p> Source code in <code>qcsys/devices/transmon.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in specified basis.\"\"\"\n    return self.original_ops[\"H_charge\"] - self.Ej * self.original_ops[\"cos(\u03c6)\"]\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.Transmon.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>qcsys/devices/transmon.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_\u03c9()\n    return w * self.original_ops[\"a_dag\"] @ self.original_ops[\"a\"]\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.Transmon.get_H_truncated","title":"<code>get_H_truncated()</code>","text":"<p>Return truncated H in specified basis.</p> Source code in <code>qcsys/devices/transmon.py</code> <pre><code>def get_H_truncated(self):\n    \"\"\"Return truncated H in specified basis.\"\"\"\n    phi_op = self.original_ops[\"phi\"]  \n    fourth_order_term =  - (1/24) * self.Ej * phi_op @ phi_op @ phi_op @ phi_op \n    sixth_order_term = (1/720) * self.Ej * phi_op @ phi_op @ phi_op @ phi_op @ phi_op @ phi_op\n    return self.get_H_linear() + fourth_order_term + sixth_order_term\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.Transmon.get_linear_\u03c9","title":"<code>get_linear_\u03c9()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>qcsys/devices/transmon.py</code> <pre><code>def get_linear_\u03c9(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return jnp.sqrt(8 * self.params[\"Ec\"] * self.Ej)\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.Transmon.n_zpf","title":"<code>n_zpf()</code>","text":"<p>Return Charge ZPF.</p> Source code in <code>qcsys/devices/transmon.py</code> <pre><code>def n_zpf(self):\n    \"\"\"Return Charge ZPF.\"\"\"\n    return (self.Ej / (32 * self.params[\"Ec\"])) ** (0.25)\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.Transmon.param_validation","title":"<code>param_validation(N, N_pre_diag, params, hamiltonian, basis)</code>  <code>classmethod</code>","text":"<p>This can be overridden by subclasses.</p> Source code in <code>qcsys/devices/transmon.py</code> <pre><code>@classmethod\ndef param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n    \"\"\" This can be overridden by subclasses.\"\"\"\n    if hamiltonian == HamiltonianTypes.linear:\n        assert basis == BasisTypes.fock, \"Linear Hamiltonian only works with Fock basis.\"\n    elif hamiltonian == HamiltonianTypes.truncated:\n        assert basis == BasisTypes.fock, \"Truncated Hamiltonian only works with Fock basis.\"\n    elif hamiltonian == HamiltonianTypes.full:\n        assert basis in [BasisTypes.charge, BasisTypes.single_charge], \"Full Hamiltonian only works with Cooper pair charge or single-electron charge bases.\"\n\n    # Set the gate offset charge to zero if not provided\n    if \"ng\" not in params:\n        params[\"ng\"] = 0.0\n\n    assert (N_pre_diag - 1) % 2 == 0, \"N_pre_diag must be odd.\"\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.Transmon.phi_zpf","title":"<code>phi_zpf()</code>","text":"<p>Return Phase ZPF.</p> Source code in <code>qcsys/devices/transmon.py</code> <pre><code>def phi_zpf(self):\n    \"\"\"Return Phase ZPF.\"\"\"\n    return (2 * self.params[\"Ec\"] / self.Ej) ** (0.25)\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.Transmon.potential","title":"<code>potential(phi)</code>","text":"<p>Return potential energy for a given phi.</p> Source code in <code>qcsys/devices/transmon.py</code> <pre><code>def potential(self, phi):\n    \"\"\"Return potential energy for a given phi.\"\"\"\n    if self.hamiltonian == HamiltonianTypes.linear:\n        return 0.5 * self.Ej * (2 * jnp.pi * phi) ** 2\n    elif self.hamiltonian == HamiltonianTypes.full:\n        return - self.Ej * jnp.cos(2 * jnp.pi * phi)\n    elif self.hamiltonian == HamiltonianTypes.truncated:\n        phi_scaled = 2 * jnp.pi * phi\n        second_order = 0.5 * self.Ej * phi_scaled ** 2\n        fourth_order =  - (1/24) * self.Ej * phi_scaled ** 4\n        sixth_order = (1/720) * self.Ej * phi_scaled ** 6\n        return second_order + fourth_order + sixth_order\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.TunableTransmon","title":"<code>TunableTransmon</code>","text":"<p>               Bases: <code>Transmon</code></p> <p>Tunable Transmon Device.</p> Source code in <code>qcsys/devices/tunable_transmon.py</code> <pre><code>@struct.dataclass\nclass TunableTransmon(Transmon):\n    \"\"\"\n    Tunable Transmon Device.\n    \"\"\"\n\n    @property\n    def Ej(self):\n        Ejsum = (self.params[\"Ej1\"] + self.params[\"Ej2\"])\n        phi_ext = 2 * jnp.pi * self.params[\"phi_ext\"]\n        gamma = self.params[\"Ej2\"]/self.params[\"Ej1\"]\n        d = (gamma - 1)/(gamma + 1)\n        external_flux_factor = jnp.abs(jnp.sqrt(jnp.cos(phi_ext/2)**2 + d**2 * jnp.sin(phi_ext/2)**2))\n        return Ejsum * external_flux_factor\n</code></pre>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.harm_osc_wavefunction","title":"<code>harm_osc_wavefunction(n, x, l_osc)</code>","text":"<p>Taken from scqubits... not jit-able</p> <p>For given quantum number n=0,1,2,... return the value of the harmonic oscillator wave function :math:<code>\\psi_n(x) = N H_n(x/l_{osc}) \\exp(-x^2/2l_\\text{ osc})</code>, N being the proper normalization factor.</p> <p>Directly uses <code>scipy.special.pbdv</code> (implementation of the parabolic cylinder function) to mitigate numerical stability issues with the more commonly used expression in terms of a Gaussian and a Hermite polynomial factor.</p>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.harm_osc_wavefunction--parameters","title":"Parameters","text":"<p>n:     index of wave function, n=0 is ground state x:     coordinate(s) where wave function is evaluated l_osc:     oscillator length, defined via &lt;0|x^2|0&gt; = l_osc^2/2</p>"},{"location":"reference/qcsys/devices/index.html#qcsys.devices.harm_osc_wavefunction--returns","title":"Returns","text":"<pre><code>value of harmonic oscillator wave function\n</code></pre> Source code in <code>qcsys/common/utils.py</code> <pre><code>def harm_osc_wavefunction(\n    n, x, l_osc\n):\n    r\"\"\"\n    Taken from scqubits... not jit-able\n\n    For given quantum number n=0,1,2,... return the value of the harmonic\n    oscillator wave function :math:`\\psi_n(x) = N H_n(x/l_{osc}) \\exp(-x^2/2l_\\text{\n    osc})`, N being the proper normalization factor.\n\n    Directly uses `scipy.special.pbdv` (implementation of the parabolic cylinder\n    function) to mitigate numerical stability issues with the more commonly used\n    expression in terms of a Gaussian and a Hermite polynomial factor.\n\n    Parameters\n    ----------\n    n:\n        index of wave function, n=0 is ground state\n    x:\n        coordinate(s) where wave function is evaluated\n    l_osc:\n        oscillator length, defined via &lt;0|x^2|0&gt; = l_osc^2/2\n\n    Returns\n    -------\n        value of harmonic oscillator wave function\n    \"\"\"\n    x = 2 * jnp.pi * x\n    result = pbdv(n, jnp.sqrt(2.0) * x / l_osc) [0]\n    result = result / jnp.sqrt(\n        l_osc * jnp.sqrt(jnp.pi) *  factorial_approx(n)\n    )\n    return result\n</code></pre>"},{"location":"reference/qcsys/devices/ats.html","title":"ats","text":"<p>ATS.</p>"},{"location":"reference/qcsys/devices/ats.html#qcsys.devices.ats.ATS","title":"<code>ATS</code>","text":"<p>               Bases: <code>FluxDevice</code></p> <p>ATS Device.</p> Source code in <code>qcsys/devices/ats.py</code> <pre><code>@struct.dataclass\nclass ATS(FluxDevice):        \n    \"\"\"\n    ATS Device.\n    \"\"\"\n\n    def common_ops(self):\n        \"\"\" Written in the linear basis. \"\"\"\n        ops = {}\n\n        N = self.N_pre_diag\n        ops[\"id\"] = jqt.identity(N)\n        ops[\"a\"] = jqt.destroy(N)\n        ops[\"a_dag\"] = jqt.create(N)\n        ops[\"phi\"] = self.phi_zpf()*(ops[\"a\"] + ops[\"a_dag\"])  \n        ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n        return ops\n\n    def phi_zpf(self):\n        \"\"\"Return Phase ZPF.\"\"\"\n        return (2*self.params[\"Ec\"]/self.params[\"El\"])**(.25)\n\n    def n_zpf(self):\n        \"\"\"Return Charge ZPF.\"\"\"\n        return (self.params[\"El\"]/(32*self.params[\"Ec\"]))**(.25)\n\n    def get_linear_\u03c9(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return jnp.sqrt(8*self.params[\"El\"]*self.params[\"Ec\"])\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_\u03c9()\n        return w*(self.linear_ops[\"a_dag\"]@self.linear_ops[\"a\"] + 0.5 * self.linear_ops[\"id\"])\n\n    @staticmethod\n    def get_H_nonlinear_static(phi_op, Ej, dEj, Ej2, phi_sum, phi_delta):\n        cos_phi_op = jqt.cosm(phi_op)\n        sin_phi_op = jqt.sinm(phi_op)\n\n        cos_2phi_op = cos_phi_op @ cos_phi_op - sin_phi_op @ sin_phi_op\n        sin_2phi_op = 2 * cos_phi_op @ sin_phi_op\n\n        H_nl_Ej = - 2 * Ej * (\n            cos_phi_op * jnp.cos(2 * jnp.pi * phi_delta) \n            - sin_phi_op * jnp.sin(2 * jnp.pi * phi_delta)\n        ) * jnp.cos(2 * jnp.pi * phi_sum)\n        H_nl_dEj = 2 * dEj * (\n            sin_phi_op * jnp.cos(2 * jnp.pi * phi_delta)\n            + cos_phi_op * jnp.sin(2 * jnp.pi * phi_delta)\n        ) * jnp.sin(2 * jnp.pi * phi_sum) \n        H_nl_Ej2 = 2 * Ej2 * (\n            cos_2phi_op * jnp.cos(2 * 2 * jnp.pi * phi_delta)\n            - sin_2phi_op * jnp.sin(2 * 2 * jnp.pi * phi_delta)\n        ) * jnp.cos(2 * 2 * jnp.pi * phi_sum)\n\n        H_nl = H_nl_Ej + H_nl_dEj + H_nl_Ej2\n\n\n        # id_op = jqt.identity_like(phi_op)\n        # phi_delta_ext_op = self.params[\"phi_delta_ext\"] * id_op\n        # H_nl_old = - 2 * Ej * jqt.cosm(phi_op + 2 * jnp.pi * phi_delta_ext_op) * jnp.cos(2 * jnp.pi * self.params[\"phi_sum_ext\"])\n        # H_nl_old += 2 * dEj * jqt.sinm(phi_op + 2 * jnp.pi * phi_delta_ext_op) * jnp.sin(2 * jnp.pi * self.params[\"phi_sum_ext\"]) \n        # H_nl_old += 2 * Ej2 * jqt.cosm(2*phi_op + 2 * 2 * jnp.pi * phi_delta_ext_op) * jnp.cos(2 * 2 * jnp.pi * self.params[\"phi_sum_ext\"])\n\n        return H_nl\n\n    def get_H_nonlinear(self, phi_op):\n        \"\"\"Return nonlinear terms in H.\"\"\"\n\n        Ej = self.params[\"Ej\"]\n        dEj = self.params[\"dEj\"]\n        Ej2 = self.params[\"Ej2\"]\n\n        phi_sum = self.params[\"phi_sum_ext\"]\n        phi_delta = self.params[\"phi_delta_ext\"]\n\n        return ATS.get_H_nonlinear_static(\n            phi_op, \n            Ej, \n            dEj, \n            Ej2, \n            phi_sum, \n            phi_delta\n        )\n\n\n    def get_H_full(self):\n        \"\"\"Return full H in linear basis.\"\"\"\n        id_op = self.linear_ops[\"id\"]\n        phi_b = self.linear_ops[\"phi\"]\n        H_nl = self.get_H_nonlinear(phi_b)\n        H = self.get_H_linear() + H_nl\n        return H\n\n    def potential(self, phi):\n        \"\"\"Return potential energy for a given phi.\"\"\"\n\n        phi_delta_ext = self.params[\"phi_delta_ext\"]\n        phi_sum_ext = self.params[\"phi_sum_ext\"]\n\n        V = 0.5 * self.params[\"El\"] * (2 * jnp.pi * phi) ** 2\n        V += - 2 * self.params[\"Ej\"] * jnp.cos(2 * jnp.pi * (phi + phi_delta_ext)) * jnp.cos(2 * jnp.pi * phi_sum_ext)\n        V += 2 * self.params[\"dEj\"] * jnp.sin(2 * jnp.pi * (phi + phi_delta_ext)) * jnp.sin(2 * jnp.pi * phi_sum_ext)\n        V += 2 * self.params[\"Ej2\"] * jnp.cos(2 * 2 * jnp.pi * (phi + phi_delta_ext)) * jnp.cos(2 * 2 * jnp.pi * phi_sum_ext)\n\n        return V\n</code></pre>"},{"location":"reference/qcsys/devices/ats.html#qcsys.devices.ats.ATS.common_ops","title":"<code>common_ops()</code>","text":"<p>Written in the linear basis.</p> Source code in <code>qcsys/devices/ats.py</code> <pre><code>def common_ops(self):\n    \"\"\" Written in the linear basis. \"\"\"\n    ops = {}\n\n    N = self.N_pre_diag\n    ops[\"id\"] = jqt.identity(N)\n    ops[\"a\"] = jqt.destroy(N)\n    ops[\"a_dag\"] = jqt.create(N)\n    ops[\"phi\"] = self.phi_zpf()*(ops[\"a\"] + ops[\"a_dag\"])  \n    ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n    return ops\n</code></pre>"},{"location":"reference/qcsys/devices/ats.html#qcsys.devices.ats.ATS.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in linear basis.</p> Source code in <code>qcsys/devices/ats.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in linear basis.\"\"\"\n    id_op = self.linear_ops[\"id\"]\n    phi_b = self.linear_ops[\"phi\"]\n    H_nl = self.get_H_nonlinear(phi_b)\n    H = self.get_H_linear() + H_nl\n    return H\n</code></pre>"},{"location":"reference/qcsys/devices/ats.html#qcsys.devices.ats.ATS.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>qcsys/devices/ats.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_\u03c9()\n    return w*(self.linear_ops[\"a_dag\"]@self.linear_ops[\"a\"] + 0.5 * self.linear_ops[\"id\"])\n</code></pre>"},{"location":"reference/qcsys/devices/ats.html#qcsys.devices.ats.ATS.get_H_nonlinear","title":"<code>get_H_nonlinear(phi_op)</code>","text":"<p>Return nonlinear terms in H.</p> Source code in <code>qcsys/devices/ats.py</code> <pre><code>def get_H_nonlinear(self, phi_op):\n    \"\"\"Return nonlinear terms in H.\"\"\"\n\n    Ej = self.params[\"Ej\"]\n    dEj = self.params[\"dEj\"]\n    Ej2 = self.params[\"Ej2\"]\n\n    phi_sum = self.params[\"phi_sum_ext\"]\n    phi_delta = self.params[\"phi_delta_ext\"]\n\n    return ATS.get_H_nonlinear_static(\n        phi_op, \n        Ej, \n        dEj, \n        Ej2, \n        phi_sum, \n        phi_delta\n    )\n</code></pre>"},{"location":"reference/qcsys/devices/ats.html#qcsys.devices.ats.ATS.get_linear_\u03c9","title":"<code>get_linear_\u03c9()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>qcsys/devices/ats.py</code> <pre><code>def get_linear_\u03c9(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return jnp.sqrt(8*self.params[\"El\"]*self.params[\"Ec\"])\n</code></pre>"},{"location":"reference/qcsys/devices/ats.html#qcsys.devices.ats.ATS.n_zpf","title":"<code>n_zpf()</code>","text":"<p>Return Charge ZPF.</p> Source code in <code>qcsys/devices/ats.py</code> <pre><code>def n_zpf(self):\n    \"\"\"Return Charge ZPF.\"\"\"\n    return (self.params[\"El\"]/(32*self.params[\"Ec\"]))**(.25)\n</code></pre>"},{"location":"reference/qcsys/devices/ats.html#qcsys.devices.ats.ATS.phi_zpf","title":"<code>phi_zpf()</code>","text":"<p>Return Phase ZPF.</p> Source code in <code>qcsys/devices/ats.py</code> <pre><code>def phi_zpf(self):\n    \"\"\"Return Phase ZPF.\"\"\"\n    return (2*self.params[\"Ec\"]/self.params[\"El\"])**(.25)\n</code></pre>"},{"location":"reference/qcsys/devices/ats.html#qcsys.devices.ats.ATS.potential","title":"<code>potential(phi)</code>","text":"<p>Return potential energy for a given phi.</p> Source code in <code>qcsys/devices/ats.py</code> <pre><code>def potential(self, phi):\n    \"\"\"Return potential energy for a given phi.\"\"\"\n\n    phi_delta_ext = self.params[\"phi_delta_ext\"]\n    phi_sum_ext = self.params[\"phi_sum_ext\"]\n\n    V = 0.5 * self.params[\"El\"] * (2 * jnp.pi * phi) ** 2\n    V += - 2 * self.params[\"Ej\"] * jnp.cos(2 * jnp.pi * (phi + phi_delta_ext)) * jnp.cos(2 * jnp.pi * phi_sum_ext)\n    V += 2 * self.params[\"dEj\"] * jnp.sin(2 * jnp.pi * (phi + phi_delta_ext)) * jnp.sin(2 * jnp.pi * phi_sum_ext)\n    V += 2 * self.params[\"Ej2\"] * jnp.cos(2 * 2 * jnp.pi * (phi + phi_delta_ext)) * jnp.cos(2 * 2 * jnp.pi * phi_sum_ext)\n\n    return V\n</code></pre>"},{"location":"reference/qcsys/devices/base.html","title":"base","text":"<p>Base device.</p>"},{"location":"reference/qcsys/devices/base.html#qcsys.devices.base.Device","title":"<code>Device</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>qcsys/devices/base.py</code> <pre><code>@struct.dataclass\nclass Device(ABC):\n    N: int = struct.field(pytree_node=False)\n    N_pre_diag: int = struct.field(pytree_node=False)\n    params: Dict[str, Any]\n    _label: int = struct.field(pytree_node=False)\n    _basis: BasisTypes = struct.field(pytree_node=False)\n    _hamiltonian: HamiltonianTypes = struct.field(pytree_node=False)\n\n    @classmethod\n    def param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n        \"\"\" This can be overridden by subclasses.\"\"\"\n        pass\n\n    @classmethod\n    def create(cls, N, params, label=0, N_pre_diag=None,use_linear=False, hamiltonian: HamiltonianTypes = None, basis: BasisTypes = None):\n        \"\"\"Create a device.\n\n        Args:\n            N (int): dimension of Hilbert space.\n            params (dict): parameters of the device.\n            label (int, optional): label for the device. Defaults to 0. This is useful when you have multiple of the same device type in the same system.\n            N_pre_diag (int, optional): dimension of Hilbert space before diagonalization. Defaults to None, in which case it is set to N. This must be greater than or rqual to N.\n            use_linear (bool): whether to use the linearized device. Defaults to False. This will override the hamiltonian keyword argument. This is a bit redundant with hamiltonian, but it is kept for backwards compatibility.\n            hamiltonian (HamiltonianTypes, optional): type of Hamiltonian. Defaults to None, in which case the full hamiltonian is used.\n            basis (BasisTypes, optional): type of basis. Defaults to None, in which case the fock basis is used.\n        \"\"\"\n\n        if N_pre_diag is None:\n            N_pre_diag = N\n\n        assert N_pre_diag &gt;= N, \"N_pre_diag must be greater than or equal to N.\"\n\n        _basis = basis if basis is not None else BasisTypes.fock\n        _hamiltonian = hamiltonian if hamiltonian is not None else HamiltonianTypes.full\n        if use_linear:\n            _hamiltonian = HamiltonianTypes.linear\n\n        cls.param_validation(N, N_pre_diag, params, _hamiltonian, _basis)\n\n        return cls(N, N_pre_diag, params, label, _basis, _hamiltonian)\n\n    @property\n    def basis(self):\n        return self._basis\n\n    @property\n    def hamiltonian(self):\n        return self._hamiltonian\n\n    @property\n    def label(self):\n        return self.__class__.__name__ + str(self._label)\n\n    @property\n    def linear_ops(self):\n        return self.common_ops()\n\n    @property\n    def original_ops(self):\n        return self.common_ops()\n\n    @property\n    def ops(self):\n        return self.full_ops()\n\n    @abstractmethod\n    def common_ops(self) -&gt; Dict[str, jqt.Qarray]:\n        \"\"\"Set up common ops in the specified basis.\"\"\"\n\n    @abstractmethod\n    def get_linear_\u03c9(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n\n    @abstractmethod\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n\n    @abstractmethod\n    def get_H_full(self):\n        \"\"\"Return full H.\"\"\"\n\n    def get_H(self):\n        \"\"\"\n        Return diagonalized H. Explicitly keep only diagonal elements of matrix.\n        \"\"\"\n        return self.get_op_in_H_eigenbasis(self._get_H_in_original_basis()).keep_only_diag_elements()\n\n    def _get_H_in_original_basis(self):\n        \"\"\" This returns the Hamiltonian in the original specified basis. This can be overridden by subclasses.\"\"\"\n\n        if self.hamiltonian == HamiltonianTypes.linear:\n            return self.get_H_linear()\n        elif self.hamiltonian == HamiltonianTypes.full:\n            return self.get_H_full()\n\n    def _calculate_eig_systems(self):\n        evs, evecs = jnp.linalg.eigh(self._get_H_in_original_basis().data)  # Hermitian\n        idxs_sorted = jnp.argsort(evs)\n        return evs[idxs_sorted], evecs[:, idxs_sorted]\n\n    @property\n    def eig_systems(self):\n        eig_systems = {}\n        eig_systems[\"vals\"], eig_systems[\"vecs\"] = self._calculate_eig_systems()\n\n        eig_systems[\"vecs\"] = eig_systems[\"vecs\"]\n        eig_systems[\"vals\"] = eig_systems[\"vals\"]\n        return eig_systems\n\n    def get_op_in_H_eigenbasis(self, op: jqt.Qarray):\n        evecs = self.eig_systems[\"vecs\"][:, : self.N]\n        dims = [[self.N], [self.N]]\n        return get_op_in_new_basis(op, evecs, dims)\n\n    def get_op_data_in_H_eigenbasis(self, op: Array):\n        evecs = self.eig_systems[\"vecs\"][:, : self.N]\n        return get_op_data_in_new_basis(op, evecs)\n\n    def get_vec_in_H_eigenbasis(self, vec: jqt.Qarray):\n        evecs = self.eig_systems[\"vecs\"][:, : self.N]\n        if vec.qtype == jqt.Qtypes.ket:\n            dims = [[self.N],[1]]\n        else:\n            dims = [[1], [self.N]]\n        return get_vec_in_new_basis(vec, evecs, dims)\n\n    def get_vec_data_in_H_eigenbasis(self, vec: Array):\n        evecs = self.eig_systems[\"vecs\"][:, : self.N]\n        return get_vec_data_in_new_basis(vec, evecs)\n\n    def full_ops(self):\n        # TODO: use JAX vmap here\n\n        linear_ops = self.linear_ops\n        ops = {}\n        for name, op in linear_ops.items():\n            ops[name] = self.get_op_in_H_eigenbasis(op)\n\n        return ops\n</code></pre>"},{"location":"reference/qcsys/devices/base.html#qcsys.devices.base.Device.common_ops","title":"<code>common_ops()</code>  <code>abstractmethod</code>","text":"<p>Set up common ops in the specified basis.</p> Source code in <code>qcsys/devices/base.py</code> <pre><code>@abstractmethod\ndef common_ops(self) -&gt; Dict[str, jqt.Qarray]:\n    \"\"\"Set up common ops in the specified basis.\"\"\"\n</code></pre>"},{"location":"reference/qcsys/devices/base.html#qcsys.devices.base.Device.create","title":"<code>create(N, params, label=0, N_pre_diag=None, use_linear=False, hamiltonian=None, basis=None)</code>  <code>classmethod</code>","text":"<p>Create a device.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>dimension of Hilbert space.</p> required <code>params</code> <code>dict</code> <p>parameters of the device.</p> required <code>label</code> <code>int</code> <p>label for the device. Defaults to 0. This is useful when you have multiple of the same device type in the same system.</p> <code>0</code> <code>N_pre_diag</code> <code>int</code> <p>dimension of Hilbert space before diagonalization. Defaults to None, in which case it is set to N. This must be greater than or rqual to N.</p> <code>None</code> <code>use_linear</code> <code>bool</code> <p>whether to use the linearized device. Defaults to False. This will override the hamiltonian keyword argument. This is a bit redundant with hamiltonian, but it is kept for backwards compatibility.</p> <code>False</code> <code>hamiltonian</code> <code>HamiltonianTypes</code> <p>type of Hamiltonian. Defaults to None, in which case the full hamiltonian is used.</p> <code>None</code> <code>basis</code> <code>BasisTypes</code> <p>type of basis. Defaults to None, in which case the fock basis is used.</p> <code>None</code> Source code in <code>qcsys/devices/base.py</code> <pre><code>@classmethod\ndef create(cls, N, params, label=0, N_pre_diag=None,use_linear=False, hamiltonian: HamiltonianTypes = None, basis: BasisTypes = None):\n    \"\"\"Create a device.\n\n    Args:\n        N (int): dimension of Hilbert space.\n        params (dict): parameters of the device.\n        label (int, optional): label for the device. Defaults to 0. This is useful when you have multiple of the same device type in the same system.\n        N_pre_diag (int, optional): dimension of Hilbert space before diagonalization. Defaults to None, in which case it is set to N. This must be greater than or rqual to N.\n        use_linear (bool): whether to use the linearized device. Defaults to False. This will override the hamiltonian keyword argument. This is a bit redundant with hamiltonian, but it is kept for backwards compatibility.\n        hamiltonian (HamiltonianTypes, optional): type of Hamiltonian. Defaults to None, in which case the full hamiltonian is used.\n        basis (BasisTypes, optional): type of basis. Defaults to None, in which case the fock basis is used.\n    \"\"\"\n\n    if N_pre_diag is None:\n        N_pre_diag = N\n\n    assert N_pre_diag &gt;= N, \"N_pre_diag must be greater than or equal to N.\"\n\n    _basis = basis if basis is not None else BasisTypes.fock\n    _hamiltonian = hamiltonian if hamiltonian is not None else HamiltonianTypes.full\n    if use_linear:\n        _hamiltonian = HamiltonianTypes.linear\n\n    cls.param_validation(N, N_pre_diag, params, _hamiltonian, _basis)\n\n    return cls(N, N_pre_diag, params, label, _basis, _hamiltonian)\n</code></pre>"},{"location":"reference/qcsys/devices/base.html#qcsys.devices.base.Device.get_H","title":"<code>get_H()</code>","text":"<p>Return diagonalized H. Explicitly keep only diagonal elements of matrix.</p> Source code in <code>qcsys/devices/base.py</code> <pre><code>def get_H(self):\n    \"\"\"\n    Return diagonalized H. Explicitly keep only diagonal elements of matrix.\n    \"\"\"\n    return self.get_op_in_H_eigenbasis(self._get_H_in_original_basis()).keep_only_diag_elements()\n</code></pre>"},{"location":"reference/qcsys/devices/base.html#qcsys.devices.base.Device.get_H_full","title":"<code>get_H_full()</code>  <code>abstractmethod</code>","text":"<p>Return full H.</p> Source code in <code>qcsys/devices/base.py</code> <pre><code>@abstractmethod\ndef get_H_full(self):\n    \"\"\"Return full H.\"\"\"\n</code></pre>"},{"location":"reference/qcsys/devices/base.html#qcsys.devices.base.Device.get_H_linear","title":"<code>get_H_linear()</code>  <code>abstractmethod</code>","text":"<p>Return linear terms in H.</p> Source code in <code>qcsys/devices/base.py</code> <pre><code>@abstractmethod\ndef get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n</code></pre>"},{"location":"reference/qcsys/devices/base.html#qcsys.devices.base.Device.get_linear_\u03c9","title":"<code>get_linear_\u03c9()</code>  <code>abstractmethod</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>qcsys/devices/base.py</code> <pre><code>@abstractmethod\ndef get_linear_\u03c9(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n</code></pre>"},{"location":"reference/qcsys/devices/base.html#qcsys.devices.base.Device.param_validation","title":"<code>param_validation(N, N_pre_diag, params, hamiltonian, basis)</code>  <code>classmethod</code>","text":"<p>This can be overridden by subclasses.</p> Source code in <code>qcsys/devices/base.py</code> <pre><code>@classmethod\ndef param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n    \"\"\" This can be overridden by subclasses.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/qcsys/devices/base.html#qcsys.devices.base.FluxDevice","title":"<code>FluxDevice</code>","text":"<p>               Bases: <code>Device</code></p> Source code in <code>qcsys/devices/base.py</code> <pre><code>@struct.dataclass\nclass FluxDevice(Device):\n    @abstractmethod\n    def phi_zpf(self):\n        \"\"\"Return Phase ZPF.\"\"\"\n\n    def _calculate_wavefunctions_fock(self, phi_vals):\n        \"\"\"Calculate wavefunctions at phi_exts.\"\"\"\n        phi_osc = self.phi_zpf() * jnp.sqrt(2) # length of oscillator\n        phi_vals = jnp.array(phi_vals)\n\n        # calculate basis functions\n        basis_functions = []\n        for n in range(self.N_pre_diag):\n            basis_functions.append(\n                harm_osc_wavefunction(n, phi_vals, jnp.real(phi_osc))\n            )\n        basis_functions = jnp.array(basis_functions)\n\n        # transform to better diagonal basis\n        basis_functions_in_H_eigenbasis = self.get_vec_data_in_H_eigenbasis(basis_functions)\n\n        # the below is equivalent to evecs_in_H_eigenbasis @ basis_functions_in_H_eigenbasis\n        # since evecs in H_eigenbasis is diagonal, i.e. the identity matrix\n        wavefunctions = basis_functions_in_H_eigenbasis \n        return wavefunctions\n\n    def _calculate_wavefunctions_charge(self, phi_vals):\n        phi_vals = jnp.array(phi_vals)\n\n        # calculate basis functions\n        basis_functions = []\n        n_max = (self.N_pre_diag - 1) // 2\n        for n in jnp.arange(-n_max, n_max + 1):\n            basis_functions.append(\n                1/(jnp.sqrt(2*jnp.pi)) * jnp.exp(1j * n * (2*jnp.pi*phi_vals))\n            )\n        basis_functions = jnp.array(basis_functions)\n\n        # transform to better diagonal basis\n        basis_functions_in_H_eigenbasis = self.get_vec_data_in_H_eigenbasis(basis_functions)\n\n        # the below is equivalent to evecs_in_H_eigenbasis @ basis_functions_in_H_eigenbasis\n        # since evecs in H_eigenbasis is diagonal, i.e. the identity matrix\n        phase_correction_factors =  (1j**(jnp.arange(0,self.N_pre_diag))).reshape(self.N_pre_diag,1) # TODO: review why these are needed...\n        wavefunctions = basis_functions_in_H_eigenbasis * phase_correction_factors\n        return wavefunctions\n\n    @abstractmethod\n    def potential(self, phi):\n        \"\"\"Return potential energy as a function of phi.\"\"\"\n\n    def plot_wavefunctions(self, phi_vals, max_n=None, which=None, ax=None, mode=\"abs\"):\n\n        if self.basis == BasisTypes.fock:\n            _calculate_wavefunctions = self._calculate_wavefunctions_fock\n        elif self.basis == BasisTypes.charge:\n            _calculate_wavefunctions = self._calculate_wavefunctions_charge\n        else:\n            raise NotImplementedError(f\"The {self.basis} is not yet supported for plotting wavefunctions.\")\n\n        \"\"\"Plot wavefunctions at phi_exts.\"\"\"\n        wavefunctions = _calculate_wavefunctions(phi_vals)\n        energy_levels = self.eig_systems[\"vals\"][:self.N]\n\n        potential = self.potential(phi_vals)\n\n        if ax is None:\n            fig, ax = plt.subplots(1,1, figsize = (3.5, 2.5), dpi = 1000)\n        else:\n            fig = ax.get_figure()\n\n        min_val = None\n        max_val = None\n\n        assert max_n is None or which is None, \"Can't specify both max_n and which\"\n\n        max_n = self.N if max_n is None else max_n\n        levels = range(max_n) if which is None else which\n\n        for n in levels:\n            if mode == \"abs\":\n                wf_vals = jnp.abs(wavefunctions[n, :])**2\n            elif mode == \"real\":\n                wf_vals = wavefunctions[n, :].real\n            elif mode == \"imag\":\n                wf_vals = wavefunctions[n, :].imag\n\n            wf_vals += energy_levels[n]\n            curr_min_val = min(wf_vals)\n            curr_max_val = max(wf_vals)\n\n            if min_val is None or curr_min_val &lt; min_val:\n                min_val = curr_min_val\n\n            if max_val is None or curr_max_val &gt; max_val:\n                max_val = curr_max_val\n\n            ax.plot(phi_vals, wf_vals, label=f\"$|${n}$\\\\rangle$\", linestyle = '-', linewidth = 1)\n            ax.fill_between(phi_vals, energy_levels[n], wf_vals, alpha=0.5)\n\n        ax.plot(phi_vals, potential, label=\"potential\", color=\"black\", linestyle = '-', linewidth = 1)\n\n        ax.set_ylim([min_val-1, max_val+1])\n\n        ax.set_xlabel(r\"$\\Phi/\\Phi_0$\")\n        ax.set_ylabel(r\"Energy [GHz]\")\n\n        if mode == \"abs\":\n            title_str = r\"$|\\psi_n(\\Phi)|^2$\"\n        elif mode == \"real\":\n            title_str = r\"Re($\\psi_n(\\Phi)$)\"\n        elif mode == \"imag\":\n            title_str = r\"Im($\\psi_n(\\Phi)$)\"\n\n        ax.set_title(f\"{title_str}\")\n\n        plt.legend(fontsize=6)\n        fig.tight_layout()\n\n        return ax\n</code></pre>"},{"location":"reference/qcsys/devices/base.html#qcsys.devices.base.FluxDevice.phi_zpf","title":"<code>phi_zpf()</code>  <code>abstractmethod</code>","text":"<p>Return Phase ZPF.</p> Source code in <code>qcsys/devices/base.py</code> <pre><code>@abstractmethod\ndef phi_zpf(self):\n    \"\"\"Return Phase ZPF.\"\"\"\n</code></pre>"},{"location":"reference/qcsys/devices/base.html#qcsys.devices.base.FluxDevice.potential","title":"<code>potential(phi)</code>  <code>abstractmethod</code>","text":"<p>Return potential energy as a function of phi.</p> Source code in <code>qcsys/devices/base.py</code> <pre><code>@abstractmethod\ndef potential(self, phi):\n    \"\"\"Return potential energy as a function of phi.\"\"\"\n</code></pre>"},{"location":"reference/qcsys/devices/drive.html","title":"drive","text":"<p>Base Drive.</p>"},{"location":"reference/qcsys/devices/drive.html#qcsys.devices.drive.Drive","title":"<code>Drive</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>qcsys/devices/drive.py</code> <pre><code>@struct.dataclass\nclass Drive(ABC):\n    N: int = struct.field(pytree_node=False)\n    \u03c9d: float\n    _label: int = struct.field(pytree_node=False)\n\n    @classmethod\n    def create(cls, M_max, \u03c9d, label=0):\n        cls.M_max = M_max\n        N = 2 * M_max + 1\n        return cls(N, \u03c9d, label)\n\n    @property\n    def label(self):\n        return self.__class__.__name__ + str(self._label)\n\n    @property\n    def ops(self):\n        return self.common_ops()\n\n    def common_ops(self) -&gt; Dict[str, jqt.Qarray]:\n        ops = {}\n\n        M_max = self.M_max\n\n        # Construct M = \u2211\u2098 m|m&gt;&lt;m| operator in drive charge basis\n        ops[\"M\"] = jqt.jnp2jqt(jnp.diag(jnp.arange(-M_max, M_max + 1)))\n\n        # Construct Id = \u2211\u2098|m&gt;&lt;m| in the drive charge basis\n        ops[\"id\"] = jqt.jnp2jqt(jnp.identity(2 * M_max + 1))\n\n        # Construct M\u208a \u2261 exp(i\u03b8) and M\u208b \u2261 exp(-i\u03b8) operators for drive\n        ops[\"M-\"] = jqt.jnp2jqt(jnp.eye(2 * M_max + 1, k=1))\n        ops[\"M+\"] = jqt.jnp2jqt(jnp.eye(2 * M_max + 1, k=-1))\n\n        # Construct cos(\u03b8) \u2261 1/2 * [M\u208a + M\u208b] = 1/2 * \u2211\u2098|m+1&gt;&lt;m| + h.c\n        ops[\"cos(\u03b8)\"] = 0.5 * (ops[\"M+\"] + ops[\"M-\"])\n\n        # Construct sin(\u03b8) \u2261 -i/2 * [M\u208a - M\u208b] = -i/2 * \u2211\u2098|m+1&gt;&lt;m| + h.c\n        ops[\"sin(\u03b8)\"] = -0.5j * (ops[\"M+\"] - ops[\"M-\"])\n\n        # Construct more general drive operators cos(k\u03b8) and sin(k\u03b8)\n        for k in range(2, M_max + 1):\n            ops[f\"M_+{k}\"] = jqt.jnp2jqt(jnp.eye(2 * M_max + 1, k=-k))\n            ops[f\"M_-{k}\"] = jqt.jnp2jqt(jnp.eye(2 * M_max + 1, k=k))\n            ops[f\"cos({k}\u03b8)\"] = 0.5 * (ops[f\"M_+{k}\"] + ops[f\"M_-{k}\"])\n            ops[f\"sin({k}\u03b8)\"] = -0.5j * (ops[f\"M_+{k}\"] - ops[f\"M_-{k}\"])\n\n        return ops\n\n    #############################################################\n\n    def get_H(self):\n        \"\"\"\n        Bare \"drive\" Hamiltonian (\u03c9d * M) in the extended Hilbert space.\n        \"\"\"\n        return self.\u03c9d * self.ops[\"M\"]\n</code></pre>"},{"location":"reference/qcsys/devices/drive.html#qcsys.devices.drive.Drive.get_H","title":"<code>get_H()</code>","text":"<p>Bare \"drive\" Hamiltonian (\u03c9d * M) in the extended Hilbert space.</p> Source code in <code>qcsys/devices/drive.py</code> <pre><code>def get_H(self):\n    \"\"\"\n    Bare \"drive\" Hamiltonian (\u03c9d * M) in the extended Hilbert space.\n    \"\"\"\n    return self.\u03c9d * self.ops[\"M\"]\n</code></pre>"},{"location":"reference/qcsys/devices/fluxonium.html","title":"fluxonium","text":"<p>Fluxonium.</p>"},{"location":"reference/qcsys/devices/fluxonium.html#qcsys.devices.fluxonium.Fluxonium","title":"<code>Fluxonium</code>","text":"<p>               Bases: <code>FluxDevice</code></p> <p>Fluxonium Device.</p> Source code in <code>qcsys/devices/fluxonium.py</code> <pre><code>@struct.dataclass\nclass Fluxonium(FluxDevice):\n    \"\"\"\n    Fluxonium Device.\n    \"\"\"\n\n    def common_ops(self):\n        \"\"\" Written in the linear basis. \"\"\"\n        ops = {}\n\n        N = self.N_pre_diag\n        ops[\"id\"] = jqt.identity(N)\n        ops[\"a\"] = jqt.destroy(N)\n        ops[\"a_dag\"] = jqt.create(N)\n        ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n        ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n        ops[\"cos(\u03c6/2)\"] = jqt.cosm(ops[\"phi\"] / 2)\n        ops[\"sin(\u03c6/2)\"] = jqt.sinm(ops[\"phi\"] / 2)\n\n        return ops\n\n    def n_zpf(self):\n        n_zpf = (self.params[\"El\"] / (32.0 * self.params[\"Ec\"])) ** (0.25)\n        return n_zpf\n\n    def phi_zpf(self):\n        \"\"\"Return Phase ZPF.\"\"\"\n        return (2 * self.params[\"Ec\"] / self.params[\"El\"]) ** (0.25)\n\n    def get_linear_\u03c9(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return jnp.sqrt(8 * self.params[\"Ec\"] * self.params[\"El\"])\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_\u03c9()\n        return w * (\n            self.linear_ops[\"a_dag\"] @ self.linear_ops[\"a\"]\n            + 0.5 * self.linear_ops[\"id\"]\n        )\n\n    def get_H_full(self):\n        \"\"\"Return full H in linear basis.\"\"\"\n\n        phi_op = self.linear_ops[\"phi\"]\n        return self.get_H_linear() + self.get_H_nonlinear(phi_op)\n\n    def get_H_nonlinear(self, phi_op):\n        op_cos_phi = jqt.cosm(phi_op)\n        op_sin_phi = jqt.sinm(phi_op)\n\n        phi_ext = self.params[\"phi_ext\"]\n        Hcos = op_cos_phi * jnp.cos(2.0 * jnp.pi * phi_ext) + op_sin_phi * jnp.sin(\n            2.0 * jnp.pi * phi_ext\n        )\n        H_nl = - self.params[\"Ej\"] * Hcos\n        return H_nl\n\n    def potential(self, phi):\n        \"\"\"Return potential energy for a given phi.\"\"\"\n        phi_ext = self.params[\"phi_ext\"]\n        V_linear = 0.5 * self.params[\"El\"] * (2 * jnp.pi * phi) ** 2\n\n        if self.hamiltonian == HamiltonianTypes.linear:\n            return V_linear\n\n        V_nonlinear = -self.params[\"Ej\"] * jnp.cos(2.0 * jnp.pi * (phi - phi_ext))\n        if self.hamiltonian == HamiltonianTypes.full:\n            return V_linear + V_nonlinear\n</code></pre>"},{"location":"reference/qcsys/devices/fluxonium.html#qcsys.devices.fluxonium.Fluxonium.common_ops","title":"<code>common_ops()</code>","text":"<p>Written in the linear basis.</p> Source code in <code>qcsys/devices/fluxonium.py</code> <pre><code>def common_ops(self):\n    \"\"\" Written in the linear basis. \"\"\"\n    ops = {}\n\n    N = self.N_pre_diag\n    ops[\"id\"] = jqt.identity(N)\n    ops[\"a\"] = jqt.destroy(N)\n    ops[\"a_dag\"] = jqt.create(N)\n    ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n    ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n    ops[\"cos(\u03c6/2)\"] = jqt.cosm(ops[\"phi\"] / 2)\n    ops[\"sin(\u03c6/2)\"] = jqt.sinm(ops[\"phi\"] / 2)\n\n    return ops\n</code></pre>"},{"location":"reference/qcsys/devices/fluxonium.html#qcsys.devices.fluxonium.Fluxonium.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in linear basis.</p> Source code in <code>qcsys/devices/fluxonium.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in linear basis.\"\"\"\n\n    phi_op = self.linear_ops[\"phi\"]\n    return self.get_H_linear() + self.get_H_nonlinear(phi_op)\n</code></pre>"},{"location":"reference/qcsys/devices/fluxonium.html#qcsys.devices.fluxonium.Fluxonium.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>qcsys/devices/fluxonium.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_\u03c9()\n    return w * (\n        self.linear_ops[\"a_dag\"] @ self.linear_ops[\"a\"]\n        + 0.5 * self.linear_ops[\"id\"]\n    )\n</code></pre>"},{"location":"reference/qcsys/devices/fluxonium.html#qcsys.devices.fluxonium.Fluxonium.get_linear_\u03c9","title":"<code>get_linear_\u03c9()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>qcsys/devices/fluxonium.py</code> <pre><code>def get_linear_\u03c9(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return jnp.sqrt(8 * self.params[\"Ec\"] * self.params[\"El\"])\n</code></pre>"},{"location":"reference/qcsys/devices/fluxonium.html#qcsys.devices.fluxonium.Fluxonium.phi_zpf","title":"<code>phi_zpf()</code>","text":"<p>Return Phase ZPF.</p> Source code in <code>qcsys/devices/fluxonium.py</code> <pre><code>def phi_zpf(self):\n    \"\"\"Return Phase ZPF.\"\"\"\n    return (2 * self.params[\"Ec\"] / self.params[\"El\"]) ** (0.25)\n</code></pre>"},{"location":"reference/qcsys/devices/fluxonium.html#qcsys.devices.fluxonium.Fluxonium.potential","title":"<code>potential(phi)</code>","text":"<p>Return potential energy for a given phi.</p> Source code in <code>qcsys/devices/fluxonium.py</code> <pre><code>def potential(self, phi):\n    \"\"\"Return potential energy for a given phi.\"\"\"\n    phi_ext = self.params[\"phi_ext\"]\n    V_linear = 0.5 * self.params[\"El\"] * (2 * jnp.pi * phi) ** 2\n\n    if self.hamiltonian == HamiltonianTypes.linear:\n        return V_linear\n\n    V_nonlinear = -self.params[\"Ej\"] * jnp.cos(2.0 * jnp.pi * (phi - phi_ext))\n    if self.hamiltonian == HamiltonianTypes.full:\n        return V_linear + V_nonlinear\n</code></pre>"},{"location":"reference/qcsys/devices/ideal_qubit.html","title":"ideal_qubit","text":"<p>IdealQubit.</p>"},{"location":"reference/qcsys/devices/ideal_qubit.html#qcsys.devices.ideal_qubit.IdealQubit","title":"<code>IdealQubit</code>","text":"<p>               Bases: <code>Device</code></p> <p>Ideal qubit Device.</p> Source code in <code>qcsys/devices/ideal_qubit.py</code> <pre><code>@struct.dataclass\nclass IdealQubit(Device):\n    \"\"\"\n    Ideal qubit Device.\n    \"\"\"\n\n    @classmethod\n    def param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n        \"\"\" This can be overridden by subclasses.\"\"\"\n        assert basis == BasisTypes.fock, \"IdealQubit is a two-level system defined in the Fock basis.\" \n        assert hamiltonian == HamiltonianTypes.full, \"IdealQubit requires a full Hamiltonian.\"\n        assert N == N_pre_diag == 2, \"IdealQubit is a two-level system.\"\n        assert \"\u03c9\" in params, \"IdealQubit requires a frequency parameter '\u03c9'.\"\n\n    def common_ops(self):\n        \"\"\"Written in the linear basis.\"\"\"\n        ops = {}\n\n        assert self.N_pre_diag == 2\n        assert self.N == 2\n\n        N = self.N_pre_diag\n        ops[\"id\"] = jqt.identity(N)\n        ops[\"sigmaz\"] = jqt.sigmaz()\n        ops[\"sigmax\"] = jqt.sigmax()\n        ops[\"sigmay\"] = jqt.sigmay()\n        ops[\"sigmam\"] = jqt.sigmam()\n        ops[\"sigmap\"] = jqt.sigmap()\n\n        return ops\n\n    def get_linear_\u03c9(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return self.params[\"\u03c9\"]\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_\u03c9()\n        return (w / 2) * self.linear_ops[\"sigma_z\"]\n\n    def get_H_full(self):\n        \"\"\"Return full H in linear basis.\"\"\"\n        return self.get_H_linear()\n</code></pre>"},{"location":"reference/qcsys/devices/ideal_qubit.html#qcsys.devices.ideal_qubit.IdealQubit.common_ops","title":"<code>common_ops()</code>","text":"<p>Written in the linear basis.</p> Source code in <code>qcsys/devices/ideal_qubit.py</code> <pre><code>def common_ops(self):\n    \"\"\"Written in the linear basis.\"\"\"\n    ops = {}\n\n    assert self.N_pre_diag == 2\n    assert self.N == 2\n\n    N = self.N_pre_diag\n    ops[\"id\"] = jqt.identity(N)\n    ops[\"sigmaz\"] = jqt.sigmaz()\n    ops[\"sigmax\"] = jqt.sigmax()\n    ops[\"sigmay\"] = jqt.sigmay()\n    ops[\"sigmam\"] = jqt.sigmam()\n    ops[\"sigmap\"] = jqt.sigmap()\n\n    return ops\n</code></pre>"},{"location":"reference/qcsys/devices/ideal_qubit.html#qcsys.devices.ideal_qubit.IdealQubit.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in linear basis.</p> Source code in <code>qcsys/devices/ideal_qubit.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in linear basis.\"\"\"\n    return self.get_H_linear()\n</code></pre>"},{"location":"reference/qcsys/devices/ideal_qubit.html#qcsys.devices.ideal_qubit.IdealQubit.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>qcsys/devices/ideal_qubit.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_\u03c9()\n    return (w / 2) * self.linear_ops[\"sigma_z\"]\n</code></pre>"},{"location":"reference/qcsys/devices/ideal_qubit.html#qcsys.devices.ideal_qubit.IdealQubit.get_linear_\u03c9","title":"<code>get_linear_\u03c9()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>qcsys/devices/ideal_qubit.py</code> <pre><code>def get_linear_\u03c9(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return self.params[\"\u03c9\"]\n</code></pre>"},{"location":"reference/qcsys/devices/ideal_qubit.html#qcsys.devices.ideal_qubit.IdealQubit.param_validation","title":"<code>param_validation(N, N_pre_diag, params, hamiltonian, basis)</code>  <code>classmethod</code>","text":"<p>This can be overridden by subclasses.</p> Source code in <code>qcsys/devices/ideal_qubit.py</code> <pre><code>@classmethod\ndef param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n    \"\"\" This can be overridden by subclasses.\"\"\"\n    assert basis == BasisTypes.fock, \"IdealQubit is a two-level system defined in the Fock basis.\" \n    assert hamiltonian == HamiltonianTypes.full, \"IdealQubit requires a full Hamiltonian.\"\n    assert N == N_pre_diag == 2, \"IdealQubit is a two-level system.\"\n    assert \"\u03c9\" in params, \"IdealQubit requires a frequency parameter '\u03c9'.\"\n</code></pre>"},{"location":"reference/qcsys/devices/kno.html","title":"kno","text":"<p>Kerr Nonlinear Oscillator</p>"},{"location":"reference/qcsys/devices/kno.html#qcsys.devices.kno.KNO","title":"<code>KNO</code>","text":"<p>               Bases: <code>Device</code></p> <p>Kerr Nonlinear Oscillator Device.</p> Source code in <code>qcsys/devices/kno.py</code> <pre><code>@struct.dataclass\nclass KNO(Device):\n    \"\"\"\n    Kerr Nonlinear Oscillator Device.\n    \"\"\"\n\n    @classmethod\n    def param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n        \"\"\" This can be overridden by subclasses.\"\"\"\n        assert basis == BasisTypes.fock, \"Kerr Nonlinear Oscillator must be defined in the Fock basis.\" \n        assert hamiltonian == HamiltonianTypes.full, \"Kerr Nonlinear Oscillator uses a full Hamiltonian.\"\n        assert \"\u03c9\" in params and \"\u03b1\" in params, \"Kerr Nonlinear Oscillator requires frequency '\u03c9' and anharmonicity '\u03b1' as parameters.\"\n\n    def common_ops(self):\n        ops = {}\n\n        N = self.N\n        ops[\"id\"] = jqt.identity(N)\n        ops[\"a\"] = jqt.destroy(N)\n        ops[\"a_dag\"] = jqt.create(N)\n        ops[\"phi\"] = (ops[\"a\"] + ops[\"a_dag\"]) / jnp.sqrt(2)\n        ops[\"n\"] = 1j * (ops[\"a_dag\"] - ops[\"a\"]) / jnp.sqrt(2)\n        return ops\n\n    def get_linear_\u03c9(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return self.params[\"\u03c9\"]\n\n    def get_anharm(self):\n        \"\"\"Get anharmonicity.\"\"\"\n        return self.params[\"\u03b1\"]\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_\u03c9()\n        return w * self.linear_ops[\"a_dag\"] @ self.linear_ops[\"a\"]\n\n    def get_H_full(self):\n        \"\"\"Return full H in linear basis.\"\"\"\n        \u03b1 = self.get_anharm()\n\n        return self.get_H_linear() + (\u03b1 / 2) * (\n            self.linear_ops[\"a_dag\"]\n            @ self.linear_ops[\"a_dag\"]\n            @ self.linear_ops[\"a\"]\n            @ self.linear_ops[\"a\"]\n        )\n</code></pre>"},{"location":"reference/qcsys/devices/kno.html#qcsys.devices.kno.KNO.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in linear basis.</p> Source code in <code>qcsys/devices/kno.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in linear basis.\"\"\"\n    \u03b1 = self.get_anharm()\n\n    return self.get_H_linear() + (\u03b1 / 2) * (\n        self.linear_ops[\"a_dag\"]\n        @ self.linear_ops[\"a_dag\"]\n        @ self.linear_ops[\"a\"]\n        @ self.linear_ops[\"a\"]\n    )\n</code></pre>"},{"location":"reference/qcsys/devices/kno.html#qcsys.devices.kno.KNO.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>qcsys/devices/kno.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_\u03c9()\n    return w * self.linear_ops[\"a_dag\"] @ self.linear_ops[\"a\"]\n</code></pre>"},{"location":"reference/qcsys/devices/kno.html#qcsys.devices.kno.KNO.get_anharm","title":"<code>get_anharm()</code>","text":"<p>Get anharmonicity.</p> Source code in <code>qcsys/devices/kno.py</code> <pre><code>def get_anharm(self):\n    \"\"\"Get anharmonicity.\"\"\"\n    return self.params[\"\u03b1\"]\n</code></pre>"},{"location":"reference/qcsys/devices/kno.html#qcsys.devices.kno.KNO.get_linear_\u03c9","title":"<code>get_linear_\u03c9()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>qcsys/devices/kno.py</code> <pre><code>def get_linear_\u03c9(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return self.params[\"\u03c9\"]\n</code></pre>"},{"location":"reference/qcsys/devices/kno.html#qcsys.devices.kno.KNO.param_validation","title":"<code>param_validation(N, N_pre_diag, params, hamiltonian, basis)</code>  <code>classmethod</code>","text":"<p>This can be overridden by subclasses.</p> Source code in <code>qcsys/devices/kno.py</code> <pre><code>@classmethod\ndef param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n    \"\"\" This can be overridden by subclasses.\"\"\"\n    assert basis == BasisTypes.fock, \"Kerr Nonlinear Oscillator must be defined in the Fock basis.\" \n    assert hamiltonian == HamiltonianTypes.full, \"Kerr Nonlinear Oscillator uses a full Hamiltonian.\"\n    assert \"\u03c9\" in params and \"\u03b1\" in params, \"Kerr Nonlinear Oscillator requires frequency '\u03c9' and anharmonicity '\u03b1' as parameters.\"\n</code></pre>"},{"location":"reference/qcsys/devices/resonator.html","title":"resonator","text":"<p>Resonator.</p>"},{"location":"reference/qcsys/devices/resonator.html#qcsys.devices.resonator.Resonator","title":"<code>Resonator</code>","text":"<p>               Bases: <code>FluxDevice</code></p> <p>Resonator Device.</p> Source code in <code>qcsys/devices/resonator.py</code> <pre><code>@struct.dataclass\nclass Resonator(FluxDevice):        \n    \"\"\"\n    Resonator Device.\n    \"\"\"\n\n    def common_ops(self):\n        \"\"\" Written in the linear basis. \"\"\"\n        ops = {}\n\n        N = self.N_pre_diag\n        ops[\"id\"] = jqt.identity(N)\n        ops[\"a\"] = jqt.destroy(N)\n        ops[\"a_dag\"] = jqt.create(N)\n        ops[\"phi\"] = self.phi_zpf()*(ops[\"a\"] + ops[\"a_dag\"])  \n        ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n        return ops\n\n    def phi_zpf(self):\n        \"\"\"Return Phase ZPF.\"\"\"\n        return (2*self.params[\"Ec\"]/self.params[\"El\"])**(.25)\n\n    def n_zpf(self):\n        n_zpf = (self.params[\"El\"] / (32.0 * self.params[\"Ec\"])) ** (0.25)\n        return n_zpf\n\n    def get_linear_\u03c9(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return jnp.sqrt(8*self.params[\"El\"]*self.params[\"Ec\"])\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_\u03c9()\n        return w*(self.linear_ops[\"a_dag\"]@self.linear_ops[\"a\"] + 1/2)\n\n    def get_H_full(self):\n        \"\"\"Return full H in linear basis.\"\"\"\n        return self.get_H_linear()\n\n    def potential(self, phi):\n        \"\"\"Return potential energy for a given phi.\"\"\"\n        return 0.5 * self.params[\"El\"] * (2 * jnp.pi * phi) ** 2\n</code></pre>"},{"location":"reference/qcsys/devices/resonator.html#qcsys.devices.resonator.Resonator.common_ops","title":"<code>common_ops()</code>","text":"<p>Written in the linear basis.</p> Source code in <code>qcsys/devices/resonator.py</code> <pre><code>def common_ops(self):\n    \"\"\" Written in the linear basis. \"\"\"\n    ops = {}\n\n    N = self.N_pre_diag\n    ops[\"id\"] = jqt.identity(N)\n    ops[\"a\"] = jqt.destroy(N)\n    ops[\"a_dag\"] = jqt.create(N)\n    ops[\"phi\"] = self.phi_zpf()*(ops[\"a\"] + ops[\"a_dag\"])  \n    ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n    return ops\n</code></pre>"},{"location":"reference/qcsys/devices/resonator.html#qcsys.devices.resonator.Resonator.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in linear basis.</p> Source code in <code>qcsys/devices/resonator.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in linear basis.\"\"\"\n    return self.get_H_linear()\n</code></pre>"},{"location":"reference/qcsys/devices/resonator.html#qcsys.devices.resonator.Resonator.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>qcsys/devices/resonator.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_\u03c9()\n    return w*(self.linear_ops[\"a_dag\"]@self.linear_ops[\"a\"] + 1/2)\n</code></pre>"},{"location":"reference/qcsys/devices/resonator.html#qcsys.devices.resonator.Resonator.get_linear_\u03c9","title":"<code>get_linear_\u03c9()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>qcsys/devices/resonator.py</code> <pre><code>def get_linear_\u03c9(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return jnp.sqrt(8*self.params[\"El\"]*self.params[\"Ec\"])\n</code></pre>"},{"location":"reference/qcsys/devices/resonator.html#qcsys.devices.resonator.Resonator.phi_zpf","title":"<code>phi_zpf()</code>","text":"<p>Return Phase ZPF.</p> Source code in <code>qcsys/devices/resonator.py</code> <pre><code>def phi_zpf(self):\n    \"\"\"Return Phase ZPF.\"\"\"\n    return (2*self.params[\"Ec\"]/self.params[\"El\"])**(.25)\n</code></pre>"},{"location":"reference/qcsys/devices/resonator.html#qcsys.devices.resonator.Resonator.potential","title":"<code>potential(phi)</code>","text":"<p>Return potential energy for a given phi.</p> Source code in <code>qcsys/devices/resonator.py</code> <pre><code>def potential(self, phi):\n    \"\"\"Return potential energy for a given phi.\"\"\"\n    return 0.5 * self.params[\"El\"] * (2 * jnp.pi * phi) ** 2\n</code></pre>"},{"location":"reference/qcsys/devices/system.html","title":"system","text":"<p>System.</p>"},{"location":"reference/qcsys/devices/transmon.html","title":"transmon","text":"<p>Transmon.</p>"},{"location":"reference/qcsys/devices/transmon.html#qcsys.devices.transmon.Transmon","title":"<code>Transmon</code>","text":"<p>               Bases: <code>FluxDevice</code></p> <p>Transmon Device.</p> Source code in <code>qcsys/devices/transmon.py</code> <pre><code>@struct.dataclass\nclass Transmon(FluxDevice):\n    \"\"\"\n    Transmon Device.\n    \"\"\"\n\n    @classmethod\n    def param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n        \"\"\" This can be overridden by subclasses.\"\"\"\n        if hamiltonian == HamiltonianTypes.linear:\n            assert basis == BasisTypes.fock, \"Linear Hamiltonian only works with Fock basis.\"\n        elif hamiltonian == HamiltonianTypes.truncated:\n            assert basis == BasisTypes.fock, \"Truncated Hamiltonian only works with Fock basis.\"\n        elif hamiltonian == HamiltonianTypes.full:\n            assert basis in [BasisTypes.charge, BasisTypes.single_charge], \"Full Hamiltonian only works with Cooper pair charge or single-electron charge bases.\"\n\n        # Set the gate offset charge to zero if not provided\n        if \"ng\" not in params:\n            params[\"ng\"] = 0.0\n\n        assert (N_pre_diag - 1) % 2 == 0, \"N_pre_diag must be odd.\"\n\n    def common_ops(self):\n        \"\"\" Written in the specified basis. \"\"\"\n\n        ops = {}\n\n        N = self.N_pre_diag\n\n        if self.basis == BasisTypes.fock:\n            ops[\"id\"] = jqt.identity(N)\n            ops[\"a\"] = jqt.destroy(N)\n            ops[\"a_dag\"] = jqt.create(N)\n            ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n            ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n        elif self.basis == BasisTypes.charge:\n            \"\"\"\n            Here H = 4 * Ec (n - ng)\u00b2 - Ej cos(\u03c6) in the Cooper pair charge basis. \n            \"\"\"\n            ops[\"id\"] = jqt.identity(N)\n            ops[\"cos(\u03c6)\"] = 0.5*(jqt.jnp2jqt(jnp.eye(N,k=1) + jnp.eye(N,k=-1)))\n            ops[\"sin(\u03c6)\"] = 0.5j*(jqt.jnp2jqt(jnp.eye(N,k=1) - jnp.eye(N,k=-1)))\n            n_max = (N - 1) // 2\n            ops[\"n\"] = jqt.jnp2jqt(jnp.diag(jnp.arange(-n_max, n_max + 1)))\n\n            n_minus_ng_array = jnp.arange(-n_max, n_max + 1) - self.params[\"ng\"] * jnp.ones(N)\n            ops[\"H_charge\"] = jqt.jnp2jqt(jnp.diag(4 * self.params[\"Ec\"] * n_minus_ng_array**2))\n\n        elif self.basis == BasisTypes.single_charge:\n            \"\"\"\n            Here H = Ec (n - 2ng)\u00b2 - Ej cos(\u03c6) in the single-electron charge basis. Using Eq. (5.36) of Kyle Serniak's\n            thesis, we have H = Ec \u2211\u2099(n - 2*ng) |n\u27e9\u27e8n| - Ej/2 * \u2211\u2099|n\u27e9\u27e8n+2| + h.c where n counts the number of electrons, \n            not Cooper pairs. Note, we use 2ng instead of ng to match the gate offset charge convention of the transmon \n            (as done in Kyle's thesis).\n            \"\"\"\n            n_max = (N - 1) // 2\n\n            ops[\"id\"] = jqt.identity(N)\n            ops[\"cos(\u03c6)\"] = 0.5*(jqt.jnp2jqt(jnp.eye(N,k=2) + jnp.eye(N,k=-2)))\n            ops[\"sin(\u03c6)\"] = 0.5j*(jqt.jnp2jqt(jnp.eye(N,k=2) - jnp.eye(N,k=-2)))\n            ops[\"cos(\u03c6/2)\"] = 0.5*(jqt.jnp2jqt(jnp.eye(N,k=1) + jnp.eye(N,k=-1)))\n            ops[\"sin(\u03c6/2)\"] = 0.5j*(jqt.jnp2jqt(jnp.eye(N,k=1) - jnp.eye(N,k=-1)))\n            ops[\"n\"] = jqt.jnp2jqt(jnp.diag(jnp.arange(-n_max, n_max + 1)))\n\n            n_minus_ng_array = jnp.arange(-n_max, n_max + 1) - 2 * self.params[\"ng\"] * jnp.ones(N)\n            ops[\"H_charge\"] = jqt.jnp2jqt(jnp.diag(self.params[\"Ec\"] * n_minus_ng_array**2))\n\n        return ops\n\n    @property\n    def Ej(self):\n        return self.params[\"Ej\"]\n\n    def phi_zpf(self):\n        \"\"\"Return Phase ZPF.\"\"\"\n        return (2 * self.params[\"Ec\"] / self.Ej) ** (0.25)\n\n    def n_zpf(self):\n        \"\"\"Return Charge ZPF.\"\"\"\n        return (self.Ej / (32 * self.params[\"Ec\"])) ** (0.25)\n\n    def get_linear_\u03c9(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return jnp.sqrt(8 * self.params[\"Ec\"] * self.Ej)\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_\u03c9()\n        return w * self.original_ops[\"a_dag\"] @ self.original_ops[\"a\"]\n\n    def get_H_full(self):\n        \"\"\"Return full H in specified basis.\"\"\"\n        return self.original_ops[\"H_charge\"] - self.Ej * self.original_ops[\"cos(\u03c6)\"]\n\n    def get_H_truncated(self):\n        \"\"\"Return truncated H in specified basis.\"\"\"\n        phi_op = self.original_ops[\"phi\"]  \n        fourth_order_term =  - (1/24) * self.Ej * phi_op @ phi_op @ phi_op @ phi_op \n        sixth_order_term = (1/720) * self.Ej * phi_op @ phi_op @ phi_op @ phi_op @ phi_op @ phi_op\n        return self.get_H_linear() + fourth_order_term + sixth_order_term\n\n    def _get_H_in_original_basis(self):\n        \"\"\" This returns the Hamiltonian in the original specified basis. This can be overridden by subclasses.\"\"\"\n\n        if self.hamiltonian == HamiltonianTypes.linear:\n            return self.get_H_linear()\n        elif self.hamiltonian == HamiltonianTypes.full:\n            return self.get_H_full()\n        elif self.hamiltonian == HamiltonianTypes.truncated:\n            return self.get_H_truncated()\n\n    def potential(self, phi):\n        \"\"\"Return potential energy for a given phi.\"\"\"\n        if self.hamiltonian == HamiltonianTypes.linear:\n            return 0.5 * self.Ej * (2 * jnp.pi * phi) ** 2\n        elif self.hamiltonian == HamiltonianTypes.full:\n            return - self.Ej * jnp.cos(2 * jnp.pi * phi)\n        elif self.hamiltonian == HamiltonianTypes.truncated:\n            phi_scaled = 2 * jnp.pi * phi\n            second_order = 0.5 * self.Ej * phi_scaled ** 2\n            fourth_order =  - (1/24) * self.Ej * phi_scaled ** 4\n            sixth_order = (1/720) * self.Ej * phi_scaled ** 6\n            return second_order + fourth_order + sixth_order\n\n    def calculate_wavefunctions(self, phi_vals):\n        \"\"\"Calculate wavefunctions at phi_exts.\"\"\"\n\n        if self.basis == BasisTypes.fock:\n            return super().calculate_wavefunctions(phi_vals)\n        elif self.basis == BasisTypes.single_charge:\n            raise NotImplementedError(\"Wavefunctions for single charge basis not yet implemented.\")\n        elif self.basis == BasisTypes.charge:\n            phi_vals = jnp.array(phi_vals)\n\n            n_labels = jnp.diag(self.original_ops[\"n\"].data)\n\n            wavefunctions = []\n            for nj in range(self.N_pre_diag):\n                wavefunction = []\n                for phi in phi_vals:\n                    wavefunction.append(\n                        (1j ** nj / jnp.sqrt(2*jnp.pi)) * jnp.sum(\n                            self.eig_systems[\"vecs\"][:,nj] * jnp.exp(1j * phi * n_labels)\n                        )\n                    )\n                wavefunctions.append(jnp.array(wavefunction))\n            return jnp.array(wavefunctions)\n</code></pre>"},{"location":"reference/qcsys/devices/transmon.html#qcsys.devices.transmon.Transmon.calculate_wavefunctions","title":"<code>calculate_wavefunctions(phi_vals)</code>","text":"<p>Calculate wavefunctions at phi_exts.</p> Source code in <code>qcsys/devices/transmon.py</code> <pre><code>def calculate_wavefunctions(self, phi_vals):\n    \"\"\"Calculate wavefunctions at phi_exts.\"\"\"\n\n    if self.basis == BasisTypes.fock:\n        return super().calculate_wavefunctions(phi_vals)\n    elif self.basis == BasisTypes.single_charge:\n        raise NotImplementedError(\"Wavefunctions for single charge basis not yet implemented.\")\n    elif self.basis == BasisTypes.charge:\n        phi_vals = jnp.array(phi_vals)\n\n        n_labels = jnp.diag(self.original_ops[\"n\"].data)\n\n        wavefunctions = []\n        for nj in range(self.N_pre_diag):\n            wavefunction = []\n            for phi in phi_vals:\n                wavefunction.append(\n                    (1j ** nj / jnp.sqrt(2*jnp.pi)) * jnp.sum(\n                        self.eig_systems[\"vecs\"][:,nj] * jnp.exp(1j * phi * n_labels)\n                    )\n                )\n            wavefunctions.append(jnp.array(wavefunction))\n        return jnp.array(wavefunctions)\n</code></pre>"},{"location":"reference/qcsys/devices/transmon.html#qcsys.devices.transmon.Transmon.common_ops","title":"<code>common_ops()</code>","text":"<p>Written in the specified basis.</p> Source code in <code>qcsys/devices/transmon.py</code> <pre><code>def common_ops(self):\n    \"\"\" Written in the specified basis. \"\"\"\n\n    ops = {}\n\n    N = self.N_pre_diag\n\n    if self.basis == BasisTypes.fock:\n        ops[\"id\"] = jqt.identity(N)\n        ops[\"a\"] = jqt.destroy(N)\n        ops[\"a_dag\"] = jqt.create(N)\n        ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n        ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n    elif self.basis == BasisTypes.charge:\n        \"\"\"\n        Here H = 4 * Ec (n - ng)\u00b2 - Ej cos(\u03c6) in the Cooper pair charge basis. \n        \"\"\"\n        ops[\"id\"] = jqt.identity(N)\n        ops[\"cos(\u03c6)\"] = 0.5*(jqt.jnp2jqt(jnp.eye(N,k=1) + jnp.eye(N,k=-1)))\n        ops[\"sin(\u03c6)\"] = 0.5j*(jqt.jnp2jqt(jnp.eye(N,k=1) - jnp.eye(N,k=-1)))\n        n_max = (N - 1) // 2\n        ops[\"n\"] = jqt.jnp2jqt(jnp.diag(jnp.arange(-n_max, n_max + 1)))\n\n        n_minus_ng_array = jnp.arange(-n_max, n_max + 1) - self.params[\"ng\"] * jnp.ones(N)\n        ops[\"H_charge\"] = jqt.jnp2jqt(jnp.diag(4 * self.params[\"Ec\"] * n_minus_ng_array**2))\n\n    elif self.basis == BasisTypes.single_charge:\n        \"\"\"\n        Here H = Ec (n - 2ng)\u00b2 - Ej cos(\u03c6) in the single-electron charge basis. Using Eq. (5.36) of Kyle Serniak's\n        thesis, we have H = Ec \u2211\u2099(n - 2*ng) |n\u27e9\u27e8n| - Ej/2 * \u2211\u2099|n\u27e9\u27e8n+2| + h.c where n counts the number of electrons, \n        not Cooper pairs. Note, we use 2ng instead of ng to match the gate offset charge convention of the transmon \n        (as done in Kyle's thesis).\n        \"\"\"\n        n_max = (N - 1) // 2\n\n        ops[\"id\"] = jqt.identity(N)\n        ops[\"cos(\u03c6)\"] = 0.5*(jqt.jnp2jqt(jnp.eye(N,k=2) + jnp.eye(N,k=-2)))\n        ops[\"sin(\u03c6)\"] = 0.5j*(jqt.jnp2jqt(jnp.eye(N,k=2) - jnp.eye(N,k=-2)))\n        ops[\"cos(\u03c6/2)\"] = 0.5*(jqt.jnp2jqt(jnp.eye(N,k=1) + jnp.eye(N,k=-1)))\n        ops[\"sin(\u03c6/2)\"] = 0.5j*(jqt.jnp2jqt(jnp.eye(N,k=1) - jnp.eye(N,k=-1)))\n        ops[\"n\"] = jqt.jnp2jqt(jnp.diag(jnp.arange(-n_max, n_max + 1)))\n\n        n_minus_ng_array = jnp.arange(-n_max, n_max + 1) - 2 * self.params[\"ng\"] * jnp.ones(N)\n        ops[\"H_charge\"] = jqt.jnp2jqt(jnp.diag(self.params[\"Ec\"] * n_minus_ng_array**2))\n\n    return ops\n</code></pre>"},{"location":"reference/qcsys/devices/transmon.html#qcsys.devices.transmon.Transmon.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in specified basis.</p> Source code in <code>qcsys/devices/transmon.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in specified basis.\"\"\"\n    return self.original_ops[\"H_charge\"] - self.Ej * self.original_ops[\"cos(\u03c6)\"]\n</code></pre>"},{"location":"reference/qcsys/devices/transmon.html#qcsys.devices.transmon.Transmon.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>qcsys/devices/transmon.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_\u03c9()\n    return w * self.original_ops[\"a_dag\"] @ self.original_ops[\"a\"]\n</code></pre>"},{"location":"reference/qcsys/devices/transmon.html#qcsys.devices.transmon.Transmon.get_H_truncated","title":"<code>get_H_truncated()</code>","text":"<p>Return truncated H in specified basis.</p> Source code in <code>qcsys/devices/transmon.py</code> <pre><code>def get_H_truncated(self):\n    \"\"\"Return truncated H in specified basis.\"\"\"\n    phi_op = self.original_ops[\"phi\"]  \n    fourth_order_term =  - (1/24) * self.Ej * phi_op @ phi_op @ phi_op @ phi_op \n    sixth_order_term = (1/720) * self.Ej * phi_op @ phi_op @ phi_op @ phi_op @ phi_op @ phi_op\n    return self.get_H_linear() + fourth_order_term + sixth_order_term\n</code></pre>"},{"location":"reference/qcsys/devices/transmon.html#qcsys.devices.transmon.Transmon.get_linear_\u03c9","title":"<code>get_linear_\u03c9()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>qcsys/devices/transmon.py</code> <pre><code>def get_linear_\u03c9(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return jnp.sqrt(8 * self.params[\"Ec\"] * self.Ej)\n</code></pre>"},{"location":"reference/qcsys/devices/transmon.html#qcsys.devices.transmon.Transmon.n_zpf","title":"<code>n_zpf()</code>","text":"<p>Return Charge ZPF.</p> Source code in <code>qcsys/devices/transmon.py</code> <pre><code>def n_zpf(self):\n    \"\"\"Return Charge ZPF.\"\"\"\n    return (self.Ej / (32 * self.params[\"Ec\"])) ** (0.25)\n</code></pre>"},{"location":"reference/qcsys/devices/transmon.html#qcsys.devices.transmon.Transmon.param_validation","title":"<code>param_validation(N, N_pre_diag, params, hamiltonian, basis)</code>  <code>classmethod</code>","text":"<p>This can be overridden by subclasses.</p> Source code in <code>qcsys/devices/transmon.py</code> <pre><code>@classmethod\ndef param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n    \"\"\" This can be overridden by subclasses.\"\"\"\n    if hamiltonian == HamiltonianTypes.linear:\n        assert basis == BasisTypes.fock, \"Linear Hamiltonian only works with Fock basis.\"\n    elif hamiltonian == HamiltonianTypes.truncated:\n        assert basis == BasisTypes.fock, \"Truncated Hamiltonian only works with Fock basis.\"\n    elif hamiltonian == HamiltonianTypes.full:\n        assert basis in [BasisTypes.charge, BasisTypes.single_charge], \"Full Hamiltonian only works with Cooper pair charge or single-electron charge bases.\"\n\n    # Set the gate offset charge to zero if not provided\n    if \"ng\" not in params:\n        params[\"ng\"] = 0.0\n\n    assert (N_pre_diag - 1) % 2 == 0, \"N_pre_diag must be odd.\"\n</code></pre>"},{"location":"reference/qcsys/devices/transmon.html#qcsys.devices.transmon.Transmon.phi_zpf","title":"<code>phi_zpf()</code>","text":"<p>Return Phase ZPF.</p> Source code in <code>qcsys/devices/transmon.py</code> <pre><code>def phi_zpf(self):\n    \"\"\"Return Phase ZPF.\"\"\"\n    return (2 * self.params[\"Ec\"] / self.Ej) ** (0.25)\n</code></pre>"},{"location":"reference/qcsys/devices/transmon.html#qcsys.devices.transmon.Transmon.potential","title":"<code>potential(phi)</code>","text":"<p>Return potential energy for a given phi.</p> Source code in <code>qcsys/devices/transmon.py</code> <pre><code>def potential(self, phi):\n    \"\"\"Return potential energy for a given phi.\"\"\"\n    if self.hamiltonian == HamiltonianTypes.linear:\n        return 0.5 * self.Ej * (2 * jnp.pi * phi) ** 2\n    elif self.hamiltonian == HamiltonianTypes.full:\n        return - self.Ej * jnp.cos(2 * jnp.pi * phi)\n    elif self.hamiltonian == HamiltonianTypes.truncated:\n        phi_scaled = 2 * jnp.pi * phi\n        second_order = 0.5 * self.Ej * phi_scaled ** 2\n        fourth_order =  - (1/24) * self.Ej * phi_scaled ** 4\n        sixth_order = (1/720) * self.Ej * phi_scaled ** 6\n        return second_order + fourth_order + sixth_order\n</code></pre>"},{"location":"reference/qcsys/devices/truncated_transmon.html","title":"truncated_transmon","text":"<p>Transmon.</p>"},{"location":"reference/qcsys/devices/truncated_transmon.html#qcsys.devices.truncated_transmon.TruncatedTransmon","title":"<code>TruncatedTransmon</code>","text":"<p>               Bases: <code>FluxDevice</code></p> <p>Transmon Device.</p> Source code in <code>qcsys/devices/truncated_transmon.py</code> <pre><code>@struct.dataclass\nclass TruncatedTransmon(FluxDevice):\n    \"\"\"\n    Transmon Device.\n    \"\"\"\n\n    def common_ops(self):\n        \"\"\" Written in the linear basis. \"\"\"\n\n        ops = {}\n\n        N = self.N_pre_diag\n        ops[\"id\"] = jqt.identity(N)\n        ops[\"a\"] = jqt.destroy(N)\n        ops[\"a_dag\"] = jqt.create(N)\n        ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n        ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n        return ops\n\n    def phi_zpf(self):\n        \"\"\"Return Phase ZPF.\"\"\"\n        return (2 * self.params[\"Ec\"] / self.params[\"Ej\"]) ** (0.25)\n\n    def n_zpf(self):\n        \"\"\"Return Charge ZPF.\"\"\"\n        return (self.params[\"Ej\"] / (32 * self.params[\"Ec\"])) ** (0.25)\n\n    def get_linear_\u03c9(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return jnp.sqrt(8 * self.params[\"Ec\"] * self.params[\"Ej\"])\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_\u03c9()\n        return w * self.linear_ops[\"a_dag\"] @ self.linear_ops[\"a\"]\n\n    def get_H_full(self):\n        \"\"\"Return full H in linear basis.\"\"\"\n        cos_phi_op = (\n            jsp.linalg.expm(1j * self.linear_ops[\"phi\"])\n            + jsp.linalg.expm(-1j * self.linear_ops[\"phi\"])\n        ) / 2\n\n        H_nl = -self.params[\"Ej\"] * cos_phi_op - self.params[\n            \"Ej\"\n        ] / 2 * jnp.linalg.matrix_power(self.linear_ops[\"phi\"], 2)\n        return self.get_H_linear() + H_nl\n\n    def potential(self, phi):\n        \"\"\"Return potential energy for a given phi.\"\"\"\n        return - self.params[\"Ej\"] * jnp.cos(2 * jnp.pi * phi)\n</code></pre>"},{"location":"reference/qcsys/devices/truncated_transmon.html#qcsys.devices.truncated_transmon.TruncatedTransmon.common_ops","title":"<code>common_ops()</code>","text":"<p>Written in the linear basis.</p> Source code in <code>qcsys/devices/truncated_transmon.py</code> <pre><code>def common_ops(self):\n    \"\"\" Written in the linear basis. \"\"\"\n\n    ops = {}\n\n    N = self.N_pre_diag\n    ops[\"id\"] = jqt.identity(N)\n    ops[\"a\"] = jqt.destroy(N)\n    ops[\"a_dag\"] = jqt.create(N)\n    ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n    ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n    return ops\n</code></pre>"},{"location":"reference/qcsys/devices/truncated_transmon.html#qcsys.devices.truncated_transmon.TruncatedTransmon.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in linear basis.</p> Source code in <code>qcsys/devices/truncated_transmon.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in linear basis.\"\"\"\n    cos_phi_op = (\n        jsp.linalg.expm(1j * self.linear_ops[\"phi\"])\n        + jsp.linalg.expm(-1j * self.linear_ops[\"phi\"])\n    ) / 2\n\n    H_nl = -self.params[\"Ej\"] * cos_phi_op - self.params[\n        \"Ej\"\n    ] / 2 * jnp.linalg.matrix_power(self.linear_ops[\"phi\"], 2)\n    return self.get_H_linear() + H_nl\n</code></pre>"},{"location":"reference/qcsys/devices/truncated_transmon.html#qcsys.devices.truncated_transmon.TruncatedTransmon.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>qcsys/devices/truncated_transmon.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_\u03c9()\n    return w * self.linear_ops[\"a_dag\"] @ self.linear_ops[\"a\"]\n</code></pre>"},{"location":"reference/qcsys/devices/truncated_transmon.html#qcsys.devices.truncated_transmon.TruncatedTransmon.get_linear_\u03c9","title":"<code>get_linear_\u03c9()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>qcsys/devices/truncated_transmon.py</code> <pre><code>def get_linear_\u03c9(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return jnp.sqrt(8 * self.params[\"Ec\"] * self.params[\"Ej\"])\n</code></pre>"},{"location":"reference/qcsys/devices/truncated_transmon.html#qcsys.devices.truncated_transmon.TruncatedTransmon.n_zpf","title":"<code>n_zpf()</code>","text":"<p>Return Charge ZPF.</p> Source code in <code>qcsys/devices/truncated_transmon.py</code> <pre><code>def n_zpf(self):\n    \"\"\"Return Charge ZPF.\"\"\"\n    return (self.params[\"Ej\"] / (32 * self.params[\"Ec\"])) ** (0.25)\n</code></pre>"},{"location":"reference/qcsys/devices/truncated_transmon.html#qcsys.devices.truncated_transmon.TruncatedTransmon.phi_zpf","title":"<code>phi_zpf()</code>","text":"<p>Return Phase ZPF.</p> Source code in <code>qcsys/devices/truncated_transmon.py</code> <pre><code>def phi_zpf(self):\n    \"\"\"Return Phase ZPF.\"\"\"\n    return (2 * self.params[\"Ec\"] / self.params[\"Ej\"]) ** (0.25)\n</code></pre>"},{"location":"reference/qcsys/devices/truncated_transmon.html#qcsys.devices.truncated_transmon.TruncatedTransmon.potential","title":"<code>potential(phi)</code>","text":"<p>Return potential energy for a given phi.</p> Source code in <code>qcsys/devices/truncated_transmon.py</code> <pre><code>def potential(self, phi):\n    \"\"\"Return potential energy for a given phi.\"\"\"\n    return - self.params[\"Ej\"] * jnp.cos(2 * jnp.pi * phi)\n</code></pre>"},{"location":"reference/qcsys/devices/tunable_transmon.html","title":"tunable_transmon","text":"<p>Tunable Transmon.</p>"},{"location":"reference/qcsys/devices/tunable_transmon.html#qcsys.devices.tunable_transmon.TunableTransmon","title":"<code>TunableTransmon</code>","text":"<p>               Bases: <code>Transmon</code></p> <p>Tunable Transmon Device.</p> Source code in <code>qcsys/devices/tunable_transmon.py</code> <pre><code>@struct.dataclass\nclass TunableTransmon(Transmon):\n    \"\"\"\n    Tunable Transmon Device.\n    \"\"\"\n\n    @property\n    def Ej(self):\n        Ejsum = (self.params[\"Ej1\"] + self.params[\"Ej2\"])\n        phi_ext = 2 * jnp.pi * self.params[\"phi_ext\"]\n        gamma = self.params[\"Ej2\"]/self.params[\"Ej1\"]\n        d = (gamma - 1)/(gamma + 1)\n        external_flux_factor = jnp.abs(jnp.sqrt(jnp.cos(phi_ext/2)**2 + d**2 * jnp.sin(phi_ext/2)**2))\n        return Ejsum * external_flux_factor\n</code></pre>"}]}